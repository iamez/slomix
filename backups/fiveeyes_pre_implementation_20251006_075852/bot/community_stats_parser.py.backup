#!/usr/bin/env python3
"""
C0RNP0RN3.LUA Format Parser
Correctly parses the actual weapon format used by c0rnp0rn3.lua
"""

import re
import discord
from typing import Dict, List, Optional, Any
from datetime import datetime

# C0RNP0RN3.LUA weapon enumeration (the actual format used)
C0RNP0RN3_WEAPONS = {
    0: "WS_KNIFE",
    1: "WS_KNIFE_KBAR", 
    2: "WS_LUGER",
    3: "WS_COLT",
    4: "WS_MP40",
    5: "WS_THOMPSON",
    6: "WS_STEN",
    7: "WS_FG42",
    8: "WS_PANZERFAUST",
    9: "WS_BAZOOKA",
    10: "WS_FLAMETHROWER",
    11: "WS_GRENADE",
    12: "WS_MORTAR",
    13: "WS_MORTAR2", 
    14: "WS_DYNAMITE",
    15: "WS_AIRSTRIKE",
    16: "WS_ARTILLERY",
    17: "WS_SATCHEL",
    18: "WS_GRENADELAUNCHER",
    19: "WS_LANDMINE",
    20: "WS_MG42",
    21: "WS_BROWNING",
    22: "WS_CARBINE",
    23: "WS_KAR98",
    24: "WS_GARAND",
    25: "WS_K43",
    26: "WS_MP34",
    27: "WS_SYRINGE"
}

class C0RNP0RN3StatsParser:
    """Parse stats files generated by c0rnp0rn3.lua with stylish Discord formatting"""
    
    def __init__(self):
        # Weapon emojis for Discord formatting
        self.weapon_emojis = {
            'WS_MP40': 'ğŸ”«',
            'WS_THOMPSON': 'âš¡',
            'WS_LUGER': 'ğŸ¯',
            'WS_COLT': 'ğŸ”°',
            'WS_PANZERFAUST': 'ğŸš€',
            'WS_GRENADELAUNCHER': 'ğŸ’¥',
            'WS_GRENADE': 'ğŸ’£',
            'WS_KNIFE': 'ğŸ—¡ï¸',
            'WS_SYRINGE': 'ğŸ’‰',
            'WS_FG42': 'ğŸª',
            'WS_KAR98': 'ğŸ¯',
            'WS_GARAND': 'â­',
            'WS_STEN': 'ğŸ”§'
        }
        
        self.team_colors = {
            1: 0xFF4444,  # Axis - Red
            2: 0x4444FF   # Allies - Blue
        }
    
    def strip_color_codes(self, text: str) -> str:
        """Remove ET Legacy color codes from text (^0-^9, ^a-^z, etc.)"""
        if not text:
            return ""
        return re.sub(r'\^[0-9a-zA-Z]', '', text)

    def parse_time_to_seconds(self, time_str: str) -> int:
        """Convert time string (MM:SS or M:SS) to seconds"""
        try:
            if ':' in time_str:
                parts = time_str.split(':')
                minutes = int(parts[0])
                seconds = int(parts[1])
                return minutes * 60 + seconds
            else:
                return int(time_str)
        except:
            return 0

    def format_accuracy_bar(self, accuracy: float) -> str:
        """Create a visual accuracy bar with blocks"""
        filled = int(accuracy / 10)  # 10% per bar
        empty = 10 - filled
        return f"{'â–ˆ' * filled}{'â–‘' * empty} {accuracy:.1f}%"
    
    def format_kd_ratio(self, kills: int, deaths: int) -> str:
        """Format K/D ratio with performance indicators"""
        if deaths == 0:
            kd = kills
            indicator = "ğŸ”¥"
        else:
            kd = kills / deaths
            if kd >= 2.0:
                indicator = "ğŸ”¥"
            elif kd >= 1.5:
                indicator = "âš¡"
            elif kd >= 1.0:
                indicator = "âš”ï¸"
            else:
                indicator = "ğŸ“ˆ"
        
        return f"{indicator} {kills}K/{deaths}D ({kd:.2f})"
    
    def create_stylish_round_embed(self, stats_data: Dict[str, Any]):
        """Create a beautiful Discord embed for round results"""
        
        map_name = stats_data.get('map_name', 'Unknown')
        round_num = stats_data.get('round_num', 1)
        outcome = stats_data.get('round_outcome', 'Unknown')
        mvp_name = stats_data.get('mvp', 'Unknown')
        players = stats_data.get('players', [])
        
        # Choose embed color based on outcome
        if outcome == 'Fullhold':
            color = 0xFF6B35  # Orange for fullhold
            outcome_emoji = 'ğŸ›¡ï¸'
        else:
            color = 0x00D2FF  # Blue for completed
            outcome_emoji = 'âœ…'
        
        embed = discord.Embed(
            title=f"ğŸ† Round {round_num} Complete",
            description=f"**ğŸ“ Map:** `{map_name}`\n{outcome_emoji} **Outcome:** {outcome}",
            color=color,
            timestamp=discord.utils.utcnow()
        )
        
        # Add MVP section
        if mvp_name != 'Unknown' and players:
            mvp_player = next((p for p in players if p['name'] == mvp_name), None)
            if mvp_player:
                mvp_kd = self.format_kd_ratio(mvp_player['kills'], mvp_player['deaths'])
                mvp_dmg = mvp_player.get('damage_given', 0)
                
                embed.add_field(
                    name="ğŸŒŸ Round MVP",
                    value=f"**{mvp_name}**\n{mvp_kd}\nğŸ’Š {mvp_dmg} DMG",
                    inline=True
                )
        
        # Add top performers with weapon highlights
        if players:
            sorted_players = sorted(players, key=lambda x: x['kd_ratio'], reverse=True)
            top_3 = sorted_players[:3]
            
            leaderboard = ""
            medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
            
            for i, player in enumerate(top_3):
                medal = medals[i] if i < 3 else "ğŸ…"
                kd_formatted = self.format_kd_ratio(player['kills'], player['deaths'])
                team_indicator = "ğŸ”´" if player['team'] == 1 else "ğŸ”µ"
                
                # Get best SKILL weapon (exclude grenades, syringes, etc.)
                weapon_stats = player.get('weapon_stats', {})
                skill_weapons = ['WS_MP40', 'WS_THOMPSON', 'WS_LUGER', 'WS_COLT', 'WS_STEN', 'WS_FG42', 'WS_KAR98', 'WS_GARAND', 'WS_CARBINE', 'WS_K43']
                best_weapon = None
                best_accuracy = 0
                
                for weapon, stats in weapon_stats.items():
                    if weapon in skill_weapons and stats['shots'] > 5 and stats['accuracy'] > best_accuracy:
                        best_accuracy = stats['accuracy']
                        best_weapon = weapon
                
                weapon_info = ""
                if best_weapon:
                    emoji = self.weapon_emojis.get(best_weapon, 'ğŸ”«')
                    weapon_name = best_weapon.replace('WS_', '')
                    weapon_info = f"\n   {emoji} Topshots: {weapon_name} ({best_accuracy:.1f}%)"
                    # Use the accuracy bar for topshots
                    accuracy_bar = self.format_accuracy_bar(best_accuracy)
                    weapon_info = f"\n   {emoji} Topshots: {weapon_name}\n   {accuracy_bar}"
                
                leaderboard += f"{medal} {team_indicator} **{player['name']}**\n"
                leaderboard += f"   {kd_formatted}\n"
                leaderboard += f"   ğŸ’Š {player.get('damage_given', 0)} DMG{weapon_info}\n\n"
            
            embed.add_field(
                name="ğŸ¯ Top Performers",
                value=leaderboard,
                inline=False
            )
        
        # Add match stats summary
        if players:
            total_kills = sum(p['kills'] for p in players)
            total_deaths = sum(p['deaths'] for p in players)
            avg_kd = total_kills / total_deaths if total_deaths > 0 else 0
            
            # Find weapon usage stats
            weapon_usage = {}
            for player in players:
                for weapon, stats in player.get('weapon_stats', {}).items():
                    if stats['shots'] > 0:
                        if weapon not in weapon_usage:
                            weapon_usage[weapon] = 0
                        weapon_usage[weapon] += stats['shots']
            
            # Most used weapon
            most_used = max(weapon_usage.items(), key=lambda x: x[1]) if weapon_usage else None
            weapon_info = ""
            if most_used:
                emoji = self.weapon_emojis.get(most_used[0], 'ğŸ”«')
                weapon_name = most_used[0].replace('WS_', '')
                weapon_info = f"\nğŸ”« Most Used: {emoji} {weapon_name}"
            
            embed.add_field(
                name="ğŸ“Š Match Summary",
                value=f"ğŸ‘¥ **{len(players)} Players**\nâš”ï¸ **{total_kills} Total Kills**\nğŸ“ˆ **{avg_kd:.2f} Avg K/D**{weapon_info}",
                inline=True
            )
        
        embed.set_footer(
            text="ET:Legacy Community Stats â€¢ c0rnp0rn3.lua"
        )
        
        return embed

    def create_detailed_player_stats(self, player: Dict[str, Any]) -> str:
        """Create detailed player stats in the beloved format"""
        
        name = player['name']
        team = player['team']
        kills = player['kills']
        deaths = player['deaths']
        kd_ratio = player['kd_ratio']
        headshots = player.get('headshots', 0)
        damage_given = player.get('damage_given', 0)
        damage_received = player.get('damage_received', 0)
        
        # Build the detailed stats string
        stats_text = f"ğŸ¯ {name} (Team {team})\n"
        stats_text += f"   Overall: {kills}K/{deaths}D (K/D: {kd_ratio:.2f})\n"
        stats_text += f"   Total Headshots: {headshots}\n"
        stats_text += f"   ğŸ’Š Damage: {damage_given} dealt / {damage_received} received\n"
        
        # Add weapon performance section
        weapon_stats = player.get('weapon_stats', {})
        if weapon_stats:
            stats_text += "   ğŸ”« Weapon Performance:\n"
            
            # Focus on key weapons
            focus_weapons = ['WS_MP40', 'WS_THOMPSON', 'WS_LUGER', 'WS_COLT', 'WS_PANZERFAUST', 'WS_GRENADELAUNCHER']
            
            for weapon in focus_weapons:
                if weapon in weapon_stats:
                    w = weapon_stats[weapon]
                    if w['shots'] > 0 or w['kills'] > 0:
                        weapon_name = weapon.replace('WS_', '')
                        stats_text += f"      {weapon_name}: {w['accuracy']:.1f}% acc ({w['hits']}/{w['shots']}) | {w['kills']}K/{w['deaths']}D | {w['headshots']} HS\n"
        
        stats_text += "-" * 60
        return stats_text

    def parse_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            if len(lines) < 2:
                return self._get_error_result("insufficient lines")

            # Parse header
            header_line = lines[0].strip()
            header_parts = header_line.split('\\')
            
            if len(header_parts) < 8:
                return self._get_error_result("invalid header format")

            server_name = header_parts[0]
            map_name = header_parts[1]
            config = header_parts[2]
            round_num = int(header_parts[3]) if header_parts[3].isdigit() else 1
            defender_team = int(header_parts[4]) if header_parts[4].isdigit() else 1
            winner_team = int(header_parts[5]) if header_parts[5].isdigit() else 1
            map_time = header_parts[6]
            actual_time = header_parts[7] if len(header_parts) > 7 else "Unknown"

            # Parse players
            players = []
            for line in lines[1:]:
                if line.strip() and '\\' in line:
                    player_data = self.parse_player_line(line)
                    if player_data:
                        players.append(player_data)

            # Calculate DPM (Damage Per Minute) using actual round time
            round_time_seconds = self.parse_time_to_seconds(actual_time)
            round_time_minutes = round_time_seconds / 60.0 if round_time_seconds > 0 else 5.0
            
            # Calculate DPM for all players
            for player in players:
                damage_given = player.get('damage_given', 0)
                if round_time_minutes > 0:
                    player['dpm'] = damage_given / round_time_minutes
                else:
                    player['dpm'] = 0.0

            # Calculate MVP
            mvp = self.calculate_mvp(players)
            
            # Determine round outcome
            round_outcome = self.determine_round_outcome(map_time, actual_time, round_num)

            return {
                'success': True,
                'map_name': map_name,
                'round_num': round_num,
                'map_time': map_time,
                'actual_time': actual_time,
                'round_outcome': round_outcome,
                'players': players,
                'mvp': mvp,
                'total_players': len(players),
                'timestamp': datetime.now().isoformat()
            }

        except Exception as e:
            print(f"âŒ Error parsing stats file {file_path}: {e}")
            return self._get_error_result(f"exception: {str(e)}")

    def parse_player_line(self, line: str) -> Optional[Dict[str, Any]]:
        """Parse a single player line using c0rnp0rn3.lua format"""
        try:
            # Split by backslash for basic info: guid\name\rounds\team\stats
            parts = line.split('\\')
            if len(parts) < 5:
                return None
                
            guid = parts[0]
            raw_name = parts[1]
            clean_name = self.strip_color_codes(raw_name)
            rounds = int(parts[2]) if parts[2].isdigit() else 0
            team = int(parts[3]) if parts[3].isdigit() else 0
            stats_section = parts[4]
            
            # Parse stats section using c0rnp0rn3 format
            stats_parts = stats_section.split()
            if len(stats_parts) < 30:
                return None
                
            weapon_mask = int(stats_parts[0])
            
            # Extract weapon statistics using c0rnp0rn3 weapon mapping
            weapon_stats = {}
            total_kills = 0
            total_deaths = 0
            total_headshots = 0
            stats_index = 1  # Start after weapon mask
            
            # Process each weapon (0-27) using c0rnp0rn3 mapping
            for weapon_id in range(28):
                if weapon_mask & (1 << weapon_id):  # Check if weapon bit is set
                    weapon_name = C0RNP0RN3_WEAPONS.get(weapon_id, f"UNKNOWN_{weapon_id}")
                    
                    if stats_index + 4 < len(stats_parts):
                        hits = int(stats_parts[stats_index])
                        shots = int(stats_parts[stats_index + 1])
                        kills = int(stats_parts[stats_index + 2])
                        deaths = int(stats_parts[stats_index + 3])
                        headshots = int(stats_parts[stats_index + 4])
                        
                        accuracy = (hits / shots * 100) if shots > 0 else 0
                        
                        weapon_stats[weapon_name] = {
                            'hits': hits,
                            'shots': shots,
                            'kills': kills,
                            'deaths': deaths,
                            'headshots': headshots,
                            'accuracy': accuracy
                        }
                        
                        total_kills += kills
                        total_deaths += deaths
                        total_headshots += headshots
                        
                        stats_index += 5

            # Calculate additional metrics
            kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills
            
            # Calculate totals
            total_shots = sum(w['shots'] for w in weapon_stats.values())
            total_hits = sum(w['hits'] for w in weapon_stats.values())
            total_accuracy = (total_hits / total_shots * 100) if total_shots > 0 else 0
            
            # Extract additional stats (after weapon data)
            additional_stats = {}
            if stats_index < len(stats_parts):
                additional_fields = stats_parts[stats_index:]
                
                if len(additional_fields) >= 10:
                    try:
                        additional_stats = {
                            'damage_given': int(additional_fields[0]) if additional_fields[0].isdigit() else 0,
                            'damage_received': int(additional_fields[1]) if additional_fields[1].isdigit() else 0,
                        }
                    except (ValueError, IndexError):
                        pass

            return {
                'guid': guid[:8],  # Truncate GUID
                'clean_name': clean_name,  # âœ… FIXED: Use clean_name
                'name': clean_name,        # Keep both for compatibility
                'raw_name': raw_name,
                'team': team,
                'rounds': rounds,
                'kills': total_kills,
                'deaths': total_deaths,
                'headshots': total_headshots,
                'kd_ratio': kd_ratio,
                'shots_total': total_shots,
                'hits_total': total_hits,
                'accuracy': total_accuracy,
                'damage_given': additional_stats.get('damage_given', 0),
                'damage_received': additional_stats.get('damage_received', 0),
                'dpm': 0.0,  # âœ… FIXED: Add DPM field (will be calculated post-processing)
                'weapon_stats': weapon_stats,
                'efficiency': total_kills / (total_kills + total_deaths) * 100 if (total_kills + total_deaths) > 0 else 0
            }

        except Exception as e:
            print(f"Error parsing player line: {e}")
            return None

    def calculate_mvp(self, players: List[Dict[str, Any]]) -> Optional[str]:
        """Calculate MVP based on K/D ratio, efficiency, and damage"""
        if not players:
            return None
            
        best_player = None
        best_score = 0
        
        for player in players:
            # MVP scoring: K/D ratio + efficiency + damage factor
            kd_score = player['kd_ratio'] * 10
            efficiency_score = player['efficiency'] 
            damage_score = player['damage_given'] / 100
            
            total_score = kd_score + efficiency_score + damage_score
            
            if total_score > best_score:
                best_score = total_score
                best_player = player
                
        return best_player['name'] if best_player else None

    def determine_round_outcome(self, map_time: str, actual_time: str, round_num: int) -> str:
        """Determine if round was fullhold based on time comparison"""
        try:
            map_seconds = self.parse_time_to_seconds(map_time)
            actual_seconds = self.parse_time_to_seconds(actual_time) if actual_time != "Unknown" else 600
            
            time_diff = map_seconds - actual_seconds
            
            if time_diff <= 30:  # Within 30 seconds = time ran out
                return "Fullhold"
            else:
                return "Completed"
                
        except:
            return "Unknown"

    def _get_error_result(self, error_type: str) -> Dict[str, Any]:
        """Return standardized error result"""
        return {
            'success': False,
            'error': error_type,
            'map_name': 'Unknown',
            'round_num': 0,
            'players': [],
            'mvp': None,
            'total_players': 0,
            'timestamp': datetime.now().isoformat()
        }

def test_c0rnporn3_parser():
    """Test the c0rnp0rn3 parser"""
    parser = C0RNP0RN3StatsParser()
    
    test_file = "2025-09-30-220944-etl_sp_delivery-round-2.txt"
    result = parser.parse_stats_file(test_file)
    
    print("=== C0RNP0RN3.LUA Parser Test ===")
    print(f"Success: {result['success']}")
    print(f"Map: {result['map_name']} Round {result['round_num']}")
    print(f"Players: {result['total_players']}")
    print(f"MVP: {result['mvp']}")
    print(f"Outcome: {result['round_outcome']}")
    
    print("\nTop 3 Players:")
    sorted_players = sorted(result['players'], key=lambda x: x['kd_ratio'], reverse=True)
    for i, player in enumerate(sorted_players[:3], 1):
        print(f"  {i}. {player['name']}: {player['kills']}K/{player['deaths']}D (K/D: {player['kd_ratio']:.2f})")
        
        # Show weapon breakdown for MP40/Thompson/Luger/Colt
        focus_weapons = ['WS_MP40', 'WS_THOMPSON', 'WS_LUGER', 'WS_COLT']
        for weapon in focus_weapons:
            if weapon in player['weapon_stats']:
                w = player['weapon_stats'][weapon]
                if w['shots'] > 0:
                    weapon_name = weapon.replace('WS_', '')
                    print(f"     {weapon_name}: {w['accuracy']:.1f}% acc ({w['hits']}/{w['shots']}) | {w['kills']}K/{w['deaths']}D | {w['headshots']} HS")

if __name__ == "__main__":
    test_c0rnporn3_parser()