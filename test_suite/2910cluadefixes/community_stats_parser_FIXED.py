#!/usr/bin/env python3
"""
C0RNP0RN3.LUA Format Parser - FIXED VERSION
Critical bugs resolved:
- BUG #1: Float parsing in extended stats
- BUG #2: Round 2 file matching
"""

import os
import re
import glob
from datetime import datetime
from typing import Any, Dict, List, Optional

# C0RNP0RN3.LUA weapon enumeration (the actual format used)
C0RNP0RN3_WEAPONS = {
    0: "WS_KNIFE",
    1: "WS_KNIFE_KBAR",
    2: "WS_LUGER",
    3: "WS_COLT",
    4: "WS_MP40",
    5: "WS_THOMPSON",
    6: "WS_STEN",
    7: "WS_FG42",
    8: "WS_PANZERFAUST",
    9: "WS_BAZOOKA",
    10: "WS_FLAMETHROWER",
    11: "WS_GRENADE",
    12: "WS_MORTAR",
    13: "WS_MORTAR2",
    14: "WS_DYNAMITE",
    15: "WS_AIRSTRIKE",
    16: "WS_ARTILLERY",
    17: "WS_SATCHEL",
    18: "WS_GRENADELAUNCHER",
    19: "WS_LANDMINE",
    20: "WS_MG42",
    21: "WS_BROWNING",
    22: "WS_CARBINE",
    23: "WS_KAR98",
    24: "WS_GARAND",
    25: "WS_K43",
    26: "WS_MP34",
    27: "WS_SYRINGE",
}


class C0RNP0RN3StatsParser:
    """Parse stats files generated by c0rnp0rn3.lua - FIXED VERSION"""

    def __init__(self):
        self.team_colors = {1: 0xFF4444, 2: 0x4444FF}

    def strip_color_codes(self, text: str) -> str:
        """Remove ET Legacy color codes from text"""
        if not text:
            return ""
        return re.sub(r'\^[0-9a-zA-Z]', '', text)

    def parse_time_to_seconds(self, time_str: str) -> int:
        """Convert time string (MM:SS or M:SS) to seconds"""
        try:
            if ':' in time_str:
                parts = time_str.split(':')
                minutes = int(parts[0])
                seconds = int(parts[1])
                return minutes * 60 + seconds
            else:
                return int(time_str)
        except BaseException:
            return 0

    def calculate_mvp(self, players: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Calculate MVP based on weighted scoring"""
        if not players:
            return None

        mvp_player = None
        max_score = -1

        for player in players:
            kills = player.get('kills', 0)
            damage = player.get('damage_given', 0)
            accuracy = player.get('total_accuracy', 0)
            kd = player.get('kd_ratio', 0)

            score = (kills * 2) + (damage * 0.01) + (accuracy * 0.5) + (kd * 10)

            if score > max_score:
                max_score = score
                mvp_player = player

        return mvp_player

    def determine_round_outcome(
        self, map_time: str, actual_time: str, round_num: int
    ) -> str:
        """Determine if round was Completed or Fullhold"""
        try:
            map_seconds = self.parse_time_to_seconds(map_time)
            actual_seconds = (
                self.parse_time_to_seconds(actual_time) if actual_time != "Unknown" else 600
            )

            if round_num == 2 and actual_time == "0:00":
                return "Unknown"

            time_diff = map_seconds - actual_seconds

            if time_diff <= 30:
                return "Fullhold"
            else:
                return "Completed"

        except BaseException:
            return "Unknown"

    def _get_error_result(self, error_type: str) -> Dict[str, Any]:
        """Return standardized error result"""
        return {
            'success': False,
            'error': error_type,
            'map_name': 'Unknown',
            'round_num': 0,
            'players': [],
            'mvp': None,
            'total_players': 0,
            'timestamp': datetime.now().isoformat(),
        }

    def parse_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file with Round 2 differential calculation"""
        try:
            if self.is_round_2_file(file_path):
                return self.parse_round_2_with_differential(file_path)
            else:
                return self.parse_regular_stats_file(file_path)

        except Exception as e:
            print(f"‚ùå Error parsing stats file {file_path}: {e}")
            import traceback
            traceback.print_exc()
            return self._get_error_result(f"exception: {str(e)}")

    def is_round_2_file(self, file_path: str) -> bool:
        """Detect if this is a Round 2 file by filename pattern"""
        filename = os.path.basename(file_path)
        return "-round-2.txt" in filename

    def find_corresponding_round_1_file(self, round_2_file_path: str) -> Optional[str]:
        """
        Find the corresponding Round 1 file for a Round 2 file
        
        FIX for BUG #2: Search in current directory if file_path has no directory
        """
        filename = os.path.basename(round_2_file_path)
        directory = os.path.dirname(round_2_file_path)
        
        # FIX: If directory is empty, use current directory
        if not directory:
            directory = "."

        # Extract date, map from Round 2 filename
        parts = filename.split('-')
        if len(parts) < 6:
            return None

        date = '-'.join(parts[:3])
        map_name = '-'.join(parts[4:-2])

        # Look for Round 1 files
        search_pattern = f"{date}-*-{map_name}-round-1.txt"

        # Check both the same directory and local_stats directory
        search_dirs = [directory]
        if not directory.endswith("local_stats") and os.path.exists("local_stats"):
            search_dirs.append("local_stats")

        potential_files = []
        for search_dir in search_dirs:
            if os.path.exists(search_dir):
                pattern_path = os.path.join(search_dir, search_pattern)
                potential_files.extend(glob.glob(pattern_path))

        if not potential_files:
            return None

        # Extract Round 2 timestamp
        r2_time_part = parts[3]
        r2_timestamp = int(r2_time_part)

        # Find the Round 1 file with the latest timestamp before Round 2
        best_r1_file = None
        best_r1_timestamp = -1

        for r1_file in potential_files:
            r1_filename = os.path.basename(r1_file)
            r1_parts = r1_filename.split('-')
            if len(r1_parts) >= 4:
                r1_time_part = r1_parts[3]
                try:
                    r1_timestamp = int(r1_time_part)
                    if r1_timestamp < r2_timestamp and r1_timestamp > best_r1_timestamp:
                        best_r1_timestamp = r1_timestamp
                        best_r1_file = r1_file
                except ValueError:
                    continue

        return best_r1_file

    def parse_round_2_with_differential(self, round_2_file_path: str) -> Dict[str, Any]:
        """Parse Round 2 file with differential calculation"""
        print(f"üîç Detected Round 2 file: {os.path.basename(round_2_file_path)}")

        round_1_file_path = self.find_corresponding_round_1_file(round_2_file_path)
        if not round_1_file_path:
            print(
                f"‚ö†Ô∏è Warning: Could not find Round 1 file for {
                    os.path.basename(round_2_file_path)}"
            )
            print("   Parsing as regular file (cumulative stats will be included)")
            return self.parse_regular_stats_file(round_2_file_path)

        print(f"üìÇ Found Round 1 file: {os.path.basename(round_1_file_path)}")

        round_1_result = self.parse_regular_stats_file(round_1_file_path)
        round_2_cumulative_result = self.parse_regular_stats_file(round_2_file_path)

        if not round_1_result['success'] or not round_2_cumulative_result['success']:
            print("‚ùå Error parsing one of the round files")
            return self._get_error_result("failed to parse round 1 or round 2")

        round_1_data = round_1_result
        round_2_cumulative_data = round_2_cumulative_result

        round_1_players = {p['guid']: p for p in round_1_data['players']}

        round_2_only_players = []
        for r2_player in round_2_cumulative_data['players']:
            guid = r2_player['guid']
            r1_player = round_1_players.get(guid)

            if r1_player:
                differential_player = {
                    'guid': guid,
                    'name': r2_player['name'],
                    'team': r2_player['team'],
                    'rounds': r2_player.get('rounds', 0),
                }

                differential_player['kills'] = r2_player['kills'] - r1_player['kills']
                differential_player['deaths'] = r2_player['deaths'] - r1_player['deaths']
                differential_player['headshots'] = r2_player['headshots'] - r1_player['headshots']
                differential_player['damage_given'] = r2_player['damage_given'] - r1_player['damage_given']
                differential_player['damage_received'] = r2_player['damage_received'] - r1_player['damage_received']
                differential_player['team_damage_given'] = r2_player['team_damage_given'] - r1_player['team_damage_given']
                differential_player['gibs'] = r2_player['gibs'] - r1_player['gibs']
                differential_player['self_kills'] = r2_player['self_kills'] - r1_player['self_kills']
                differential_player['team_kills'] = r2_player['team_kills'] - r1_player['team_kills']

                differential_player['weapon_stats'] = {}
                for weapon_name, r2_weapon in r2_player.get('weapon_stats', {}).items():
                    r1_weapon = r1_player.get('weapon_stats', {}).get(weapon_name, {
                        'hits': 0, 'shots': 0, 'kills': 0, 'deaths': 0, 'headshots': 0
                    })
                    
                    diff_hits = r2_weapon['hits'] - r1_weapon['hits']
                    diff_shots = r2_weapon['shots'] - r1_weapon['shots']
                    diff_kills = r2_weapon['kills'] - r1_weapon['kills']
                    diff_deaths = r2_weapon['deaths'] - r1_weapon['deaths']
                    diff_headshots = r2_weapon['headshots'] - r1_weapon['headshots']
                    
                    differential_player['weapon_stats'][weapon_name] = {
                        'hits': diff_hits,
                        'shots': diff_shots,
                        'kills': diff_kills,
                        'deaths': diff_deaths,
                        'headshots': diff_headshots,
                        'accuracy': (diff_hits / diff_shots * 100) if diff_shots > 0 else 0,
                    }

                total_shots = sum(w['shots'] for w in differential_player['weapon_stats'].values())
                total_hits = sum(w['hits'] for w in differential_player['weapon_stats'].values())
                differential_player['total_shots'] = total_shots
                differential_player['total_hits'] = total_hits
                differential_player['total_accuracy'] = (total_hits / total_shots * 100) if total_shots > 0 else 0

                r2_time = r2_player.get('time_played_seconds', 0)
                r1_time = r1_player.get('time_played_seconds', 0)
                differential_player['time_played_seconds'] = r2_time - r1_time

                diff_kills = differential_player['kills']
                diff_deaths = differential_player['deaths']
                differential_player['kd_ratio'] = diff_kills / diff_deaths if diff_deaths > 0 else diff_kills

            else:
                differential_player = r2_player.copy()

            diff_seconds = differential_player.get('time_played_seconds', 0)
            if diff_seconds > 0:
                differential_player['dpm'] = (
                    differential_player['damage_given'] * 60
                ) / diff_seconds
            else:
                differential_player['dpm'] = 0.0

            total_kills = differential_player['kills']
            total_deaths = differential_player['deaths']
            differential_player['efficiency'] = (
                total_kills / (total_kills + total_deaths) * 100
                if (total_kills + total_deaths) > 0
                else 0
            )

            round_2_only_players.append(differential_player)

        mvp = self.calculate_mvp(round_2_only_players)

        return {
            'success': True,
            'map_name': round_2_cumulative_data['map_name'],
            'round_num': 2,
            'map_time': round_2_cumulative_data['map_time'],
            'actual_time': round_2_cumulative_data['actual_time'],
            'round_outcome': round_2_cumulative_data['round_outcome'],
            'players': round_2_only_players,
            'mvp': mvp,
            'total_players': len(round_2_only_players),
            'timestamp': datetime.now().isoformat(),
            'differential_calculation': True,
        }

    def parse_regular_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            if len(lines) < 2:
                return self._get_error_result("insufficient lines")

            header_line = lines[0].strip()
            header_parts = header_line.split('\\')

            if len(header_parts) < 8:
                return self._get_error_result("invalid header format")

            header_parts[0]
            map_name = header_parts[1]
            header_parts[2]
            round_num = int(header_parts[3]) if header_parts[3].isdigit() else 1
            defender_team = int(header_parts[4]) if header_parts[4].isdigit() else 1
            winner_team = int(header_parts[5]) if header_parts[5].isdigit() else 0
            map_time = header_parts[6]
            actual_time = header_parts[7] if len(header_parts) > 7 else "Unknown"

            actual_playtime_seconds = None
            if len(header_parts) >= 9:
                try:
                    actual_playtime_seconds = float(header_parts[8])
                except (ValueError, IndexError):
                    actual_playtime_seconds = None

            players = []
            for line in lines[1:]:
                if line.strip() and '\\' in line:
                    player_data = self.parse_player_line(line)
                    if player_data:
                        players.append(player_data)

            if actual_playtime_seconds is not None:
                round_time_seconds = int(actual_playtime_seconds)
            else:
                round_time_seconds = self.parse_time_to_seconds(actual_time)
                if round_time_seconds == 0:
                    round_time_seconds = 300

            for player in players:
                damage_given = player.get('damage_given', 0)
                player['time_played_seconds'] = round_time_seconds

                minutes = round_time_seconds // 60
                seconds = round_time_seconds % 60
                player['time_display'] = f"{minutes}:{seconds:02d}"

                if round_time_seconds > 0:
                    player['dpm'] = (damage_given * 60) / round_time_seconds
                else:
                    player['dpm'] = 0.0

                player['time_played_minutes'] = round_time_seconds / 60.0

            mvp = self.calculate_mvp(players)
            round_outcome = self.determine_round_outcome(map_time, actual_time, round_num)

            return {
                'success': True,
                'map_name': map_name,
                'round_num': round_num,
                'defender_team': defender_team,
                'winner_team': winner_team,
                'map_time': map_time,
                'actual_time': actual_time,
                'round_outcome': round_outcome,
                'players': players,
                'mvp': mvp,
                'total_players': len(players),
                'timestamp': datetime.now().isoformat(),
            }

        except Exception as e:
            print(f"‚ùå Error parsing stats file {file_path}: {e}")
            import traceback
            traceback.print_exc()
            return self._get_error_result(f"exception: {str(e)}")

    def parse_player_line(self, line: str) -> Optional[Dict[str, Any]]:
        """
        Parse a single player line using c0rnp0rn3.lua format
        
        FIX for BUG #1: Use float() for float fields instead of int()
        """
        try:
            parts = line.split('\\')
            if len(parts) < 5:
                return None

            guid = parts[0]
            raw_name = parts[1]
            clean_name = self.strip_color_codes(raw_name)
            rounds = int(parts[2]) if parts[2].isdigit() else 0
            team = int(parts[3]) if parts[3].isdigit() else 0
            stats_section = parts[4]

            if '\t' in stats_section:
                weapon_section, extended_section = stats_section.split('\t', 1)
                stats_parts = weapon_section.split()
            else:
                stats_parts = stats_section.split()
                extended_section = None

            if len(stats_parts) < 6:
                return None

            weapon_mask = int(stats_parts[0])

            weapon_stats = {}
            total_kills = 0
            total_deaths = 0
            total_headshots = 0
            stats_index = 1

            for weapon_id in range(28):
                if weapon_mask & (1 << weapon_id):
                    weapon_name = C0RNP0RN3_WEAPONS.get(weapon_id, f"UNKNOWN_{weapon_id}")

                    if stats_index + 4 < len(stats_parts):
                        hits = int(stats_parts[stats_index])
                        shots = int(stats_parts[stats_index + 1])
                        kills = int(stats_parts[stats_index + 2])
                        deaths = int(stats_parts[stats_index + 3])
                        headshots = int(stats_parts[stats_index + 4])

                        accuracy = (hits / shots * 100) if shots > 0 else 0

                        weapon_stats[weapon_name] = {
                            'hits': hits,
                            'shots': shots,
                            'kills': kills,
                            'deaths': deaths,
                            'headshots': headshots,
                            'accuracy': accuracy,
                        }

                        total_kills += kills
                        total_deaths += deaths
                        total_headshots += headshots

                        stats_index += 5

            kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills

            total_shots = sum(w['shots'] for w in weapon_stats.values())
            total_hits = sum(w['hits'] for w in weapon_stats.values())
            total_accuracy = (total_hits / total_shots * 100) if total_shots > 0 else 0

            additional_stats = {}
            objective_stats = {}

            if extended_section:
                tab_fields = extended_section.split('\t')

                if len(tab_fields) >= 33:
                    try:
                        # FIX: Use appropriate type based on c0rnp0rn7.lua format string (line 270)
                        # Format: %d %d %d %d %d %d %d %d %0.1f %d %d...[11x %d]... %0.1f %0.1f %0.1f %0.1f %0.1f %0.1f %d...[11x %d]
                        additional_stats = {
                            'damage_given': int(tab_fields[0]),          # %d
                            'damage_received': int(tab_fields[1]),       # %d
                            'team_damage_given': int(tab_fields[2]),     # %d
                            'team_damage_received': int(tab_fields[3]),  # %d
                            'gibs': int(tab_fields[4]),                  # %d
                            'self_kills': int(tab_fields[5]),            # %d
                            'team_kills': int(tab_fields[6]),            # %d
                            'team_gibs': int(tab_fields[7]),             # %d
                            'time_played': float(tab_fields[8]),         # %0.1f - FLOAT!
                        }

                        objective_stats = {
                            'health_given': int(tab_fields[9]),          # %d (xp in lua, but means health)
                            'revives': int(tab_fields[10]),              # %d (topshots[1])
                            'ammo_given': int(tab_fields[11]),           # %d (topshots[2])
                            'construction': int(tab_fields[12]),         # %d (topshots[3])
                            'demolition': int(tab_fields[13]),           # %d (topshots[4])
                            'captures': int(tab_fields[14]),             # %d (topshots[5])
                            'damage_team_given': int(tab_fields[15]),    # %d (topshots[6])
                            'damage_team_received': int(tab_fields[16]), # %d (topshots[7])
                            'poison': int(tab_fields[17]),               # %d (topshots[8])
                            'teleporter_travel': int(tab_fields[18]),    # %d (topshots[9])
                            'teleporter_usage': int(tab_fields[19]),     # %d (topshots[10])
                            'defused': int(tab_fields[20]),              # %d (topshots[11])
                            'planted': float(tab_fields[21]),            # %0.1f - FLOAT! (topshots[12])
                            'xp': float(tab_fields[22]),                 # %0.1f - FLOAT! (roundNum((tp/1000)/60, 1))
                            'combatxp': float(tab_fields[23]),           # %0.1f - FLOAT! (topshots[13])
                            'time_axis': float(tab_fields[24]),          # %0.1f - FLOAT! (topshots[14])
                            'time_allies': float(tab_fields[25]),        # %0.1f - FLOAT! (death_time_total/60000)
                            'kd': float(tab_fields[26]),                 # %0.1f - FLOAT! (kd ratio)
                            'multikill_2': int(tab_fields[27]),          # %d (topshots[15])
                            'deny_time': int(tab_fields[28]),            # %d (floor(topshots[16]/1000))
                            'multikill_3': int(tab_fields[29]),          # %d (multikills[1])
                            'multikill_4': int(tab_fields[30]),          # %d (multikills[2])
                            'multikill_5': int(tab_fields[31]),          # %d (multikills[3])
                            'best_spree': int(tab_fields[32]),           # %d (multikills[4])
                            'denied': int(tab_fields[33]),               # %d (multikills[5])
                        }
                        
                        # Add more fields if available (up to index 37)
                        if len(tab_fields) > 34:
                            objective_stats['topshots_17'] = int(tab_fields[34])  # %d
                        if len(tab_fields) > 35:
                            objective_stats['topshots_18'] = int(tab_fields[35])  # %d
                        if len(tab_fields) > 36:
                            objective_stats['topshots_19'] = int(tab_fields[36])  # %d
                        if len(tab_fields) > 37:
                            objective_stats['topshots_20'] = int(tab_fields[37])  # %d
                    except (ValueError, IndexError) as e:
                        print(f"‚ö†Ô∏è Warning: Failed to parse extended stats for {clean_name}: {e}")
                        additional_stats = {'damage_given': 0, 'damage_received': 0}
                        objective_stats = {}

            player = {
                'guid': guid,
                'name': clean_name,
                'rounds': rounds,
                'team': team,
                'kills': total_kills,
                'deaths': total_deaths,
                'headshots': total_headshots,
                'kd_ratio': kd_ratio,
                'total_shots': total_shots,
                'total_hits': total_hits,
                'total_accuracy': total_accuracy,
                'weapon_stats': weapon_stats,
                **additional_stats,
                **objective_stats,
            }

            return player

        except Exception as e:
            print(f"‚ö†Ô∏è Failed to parse player line: {e}")
            import traceback
            traceback.print_exc()
            return None


def test_fixed_parser():
    """Test the fixed parser"""
    parser = C0RNP0RN3StatsParser()
    
    test_files = glob.glob("*.txt")
    
    if not test_files:
        print("No test files found!")
        return

    for test_file in test_files:
        print(f"\n{'='*80}")
        print(f"Testing FIXED: {test_file}")
        print('='*80)
        
        result = parser.parse_stats_file(test_file)

        print(f"Success: {result['success']}")
        if result['success']:
            print(f"Map: {result['map_name']} Round {result['round_num']}")
            print(f"Players: {result['total_players']}")
            print(f"MVP: {result['mvp']['name'] if result['mvp'] else 'None'}")
            print(f"Outcome: {result['round_outcome']}")
            print(f"Differential: {result.get('differential_calculation', False)}")

            print("\nTop 3 Players by K/D:")
            sorted_players = sorted(result['players'], key=lambda x: x['kd_ratio'], reverse=True)
            for i, player in enumerate(sorted_players[:3], 1):
                print(
                    f"  {i}. {player['name']}: {player['kills']}K/{player['deaths']}D "
                    f"(K/D: {player['kd_ratio']:.2f}, Damage: {player.get('damage_given', 0)}, "
                    f"DPM: {player.get('dpm', 0):.1f})"
                )
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")


if __name__ == "__main__":
    test_fixed_parser()
