#!/usr/bin/env python3
"""
C0RNP0RN3.LUA Format Parser
Correctly parses the actual weapon format used by c0rnp0rn3.lua
"""

import os
import re
import glob
from datetime import datetime
from typing import Any, Dict, List, Optional

# C0RNP0RN3.LUA weapon enumeration (the actual format used)
C0RNP0RN3_WEAPONS = {
    0: "WS_KNIFE",
    1: "WS_KNIFE_KBAR",
    2: "WS_LUGER",
    3: "WS_COLT",
    4: "WS_MP40",
    5: "WS_THOMPSON",
    6: "WS_STEN",
    7: "WS_FG42",
    8: "WS_PANZERFAUST",
    9: "WS_BAZOOKA",
    10: "WS_FLAMETHROWER",
    11: "WS_GRENADE",
    12: "WS_MORTAR",
    13: "WS_MORTAR2",
    14: "WS_DYNAMITE",
    15: "WS_AIRSTRIKE",
    16: "WS_ARTILLERY",
    17: "WS_SATCHEL",
    18: "WS_GRENADELAUNCHER",
    19: "WS_LANDMINE",
    20: "WS_MG42",
    21: "WS_BROWNING",
    22: "WS_CARBINE",
    23: "WS_KAR98",
    24: "WS_GARAND",
    25: "WS_K43",
    26: "WS_MP34",
    27: "WS_SYRINGE",
}


class C0RNP0RN3StatsParser:
    """Parse stats files generated by c0rnp0rn3.lua with stylish Discord formatting"""

    def __init__(self):
        self.team_colors = {1: 0xFF4444, 2: 0x4444FF}  # Axis - Red  # Allies - Blue

    def strip_color_codes(self, text: str) -> str:
        """Remove ET Legacy color codes from text (^0-^9, ^a-^z, etc.)"""
        if not text:
            return ""
        return re.sub(r'\^[0-9a-zA-Z]', '', text)

    def parse_time_to_seconds(self, time_str: str) -> int:
        """Convert time string (MM:SS or M:SS) to seconds"""
        try:
            if ':' in time_str:
                parts = time_str.split(':')
                minutes = int(parts[0])
                seconds = int(parts[1])
                return minutes * 60 + seconds
            else:
                return int(time_str)
        except BaseException:
            return 0

    def calculate_mvp(self, players: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """Calculate MVP based on weighted scoring"""
        if not players:
            return None

        mvp_player = None
        max_score = -1

        for player in players:
            # MVP scoring: kills, damage, accuracy, K/D
            kills = player.get('kills', 0)
            damage = player.get('damage_given', 0)
            accuracy = player.get('total_accuracy', 0)
            kd = player.get('kd_ratio', 0)

            score = (kills * 2) + (damage * 0.01) + (accuracy * 0.5) + (kd * 10)

            if score > max_score:
                max_score = score
                mvp_player = player

        return mvp_player

    def determine_round_outcome(
        self, map_time: str, actual_time: str, round_num: int
    ) -> str:
        """
        Determine if round was Completed or Fullhold based on time difference.
        Returns "Unknown" if actual_time is malformed.

        actual_time == "Unknown" in ~10% of files.
        This likely indicates the g_nextTimeLimit cvar was reset/not set.
        We treat this as "Unknown" to preserve data integrity.
        See dev/TIME_FORMAT_ANALYSIS.md for details.
        """
        try:
            map_seconds = self.parse_time_to_seconds(map_time)
            actual_seconds = (
                self.parse_time_to_seconds(actual_time) if actual_time != "Unknown" else 600
            )

            # Special case: Round 2 with 0:00 actual_time
            # This appears in ~20% of Round 2 files, meaning unclear
            if round_num == 2 and actual_time == "0:00":
                return "Unknown"

            time_diff = map_seconds - actual_seconds

            if time_diff <= 30:  # Within 30 seconds = time ran out
                return "Fullhold"
            else:
                return "Completed"

        except BaseException:
            return "Unknown"

    def _get_error_result(self, error_type: str) -> Dict[str, Any]:
        """Return standardized error result"""
        return {
            'success': False,
            'error': error_type,
            'map_name': 'Unknown',
            'round_num': 0,
            'players': [],
            'mvp': None,
            'total_players': 0,
            'timestamp': datetime.now().isoformat(),
        }

    def parse_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file with Round 2 differential calculation"""
        try:
            # Check if this is a Round 2 file and needs differential calculation
            if self.is_round_2_file(file_path):
                return self.parse_round_2_with_differential(file_path)
            else:
                return self.parse_regular_stats_file(file_path)

        except Exception as e:
            print(f"‚ùå Error parsing stats file {file_path}: {e}")
            import traceback
            traceback.print_exc()
            return self._get_error_result(f"exception: {str(e)}")

    def is_round_2_file(self, file_path: str) -> bool:
        """Detect if this is a Round 2 file by filename pattern"""
        filename = os.path.basename(file_path)
        return "-round-2.txt" in filename

    def find_corresponding_round_1_file(self, round_2_file_path: str) -> Optional[str]:
        """Find the corresponding Round 1 file for a Round 2 file"""
        filename = os.path.basename(round_2_file_path)
        directory = os.path.dirname(round_2_file_path)

        # Extract date, map from Round 2 filename: YYYY-MM-DD-HHMMSS-mapname-round-2.txt
        parts = filename.split('-')
        if len(parts) < 6:
            return None

        date = '-'.join(parts[:3])  # YYYY-MM-DD
        map_name = '-'.join(parts[4:-2])  # everything between time and "round-2.txt"

        # Look for Round 1 files on the same date with the same map
        search_pattern = f"{date}-*-{map_name}-round-1.txt"

        # Check both the same directory and local_stats directory
        search_dirs = [directory]
        if not directory.endswith("local_stats"):
            search_dirs.append("local_stats")

        potential_files = []
        for search_dir in search_dirs:
            if os.path.exists(search_dir):
                pattern_path = os.path.join(search_dir, search_pattern)
                potential_files.extend(glob.glob(pattern_path))

        if not potential_files:
            return None

        # Extract Round 2 timestamp for comparison
        r2_time_part = parts[3]  # HHMMSS
        r2_timestamp = int(r2_time_part)

        # Find the Round 1 file with the latest timestamp before Round 2
        best_r1_file = None
        best_r1_timestamp = -1

        for r1_file in potential_files:
            r1_filename = os.path.basename(r1_file)
            r1_parts = r1_filename.split('-')
            if len(r1_parts) >= 4:
                r1_time_part = r1_parts[3]  # HHMMSS
                try:
                    r1_timestamp = int(r1_time_part)
                    # Find the Round 1 file closest to but before Round 2
                    if r1_timestamp < r2_timestamp and r1_timestamp > best_r1_timestamp:
                        best_r1_timestamp = r1_timestamp
                        best_r1_file = r1_file
                except ValueError:
                    continue

        return best_r1_file

    def parse_round_2_with_differential(self, round_2_file_path: str) -> Dict[str, Any]:
        """Parse Round 2 file with differential calculation to get Round 2-only stats"""
        print(f"üîç Detected Round 2 file: {os.path.basename(round_2_file_path)}")

        # Find corresponding Round 1 file
        round_1_file_path = self.find_corresponding_round_1_file(round_2_file_path)
        if not round_1_file_path:
            print(
                f"‚ö†Ô∏è Warning: Could not find Round 1 file for {
                    os.path.basename(round_2_file_path)}"
            )
            print("   Parsing as regular file (cumulative stats will be included)")
            return self.parse_regular_stats_file(round_2_file_path)

        print(f"üìÇ Found Round 1 file: {os.path.basename(round_1_file_path)}")

        # Parse both files
        round_1_result = self.parse_regular_stats_file(round_1_file_path)
        round_2_cumulative_result = self.parse_regular_stats_file(round_2_file_path)

        if not round_1_result['success'] or not round_2_cumulative_result['success']:
            print("‚ùå Error parsing one of the round files")
            return self._get_error_result("failed to parse round 1 or round 2")

        round_1_data = round_1_result
        round_2_cumulative_data = round_2_cumulative_result

        # Create player lookup for Round 1
        round_1_players = {p['guid']: p for p in round_1_data['players']}

        # Calculate differential stats for each player
        round_2_only_players = []
        for r2_player in round_2_cumulative_data['players']:
            guid = r2_player['guid']
            r1_player = round_1_players.get(guid)

            if r1_player:
                # Player was in both rounds - calculate differential
                differential_player = {
                    'guid': guid,
                    'name': r2_player['name'],
                    'team': r2_player['team'],
                    'rounds': r2_player.get('rounds', 0),
                }

                # Subtract Round 1 stats from Round 2 cumulative stats
                differential_player['kills'] = r2_player['kills'] - r1_player['kills']
                differential_player['deaths'] = r2_player['deaths'] - r1_player['deaths']
                differential_player['headshots'] = r2_player['headshots'] - r1_player['headshots']
                differential_player['damage_given'] = r2_player['damage_given'] - r1_player['damage_given']
                differential_player['damage_received'] = r2_player['damage_received'] - r1_player['damage_received']
                differential_player['team_damage_given'] = r2_player['team_damage_given'] - r1_player['team_damage_given']
                differential_player['gibs'] = r2_player['gibs'] - r1_player['gibs']
                differential_player['self_kills'] = r2_player['self_kills'] - r1_player['self_kills']
                differential_player['team_kills'] = r2_player['team_kills'] - r1_player['team_kills']

                # Weapon stats differential
                differential_player['weapon_stats'] = {}
                for weapon_name, r2_weapon in r2_player.get('weapon_stats', {}).items():
                    r1_weapon = r1_player.get('weapon_stats', {}).get(weapon_name, {
                        'hits': 0, 'shots': 0, 'kills': 0, 'deaths': 0, 'headshots': 0
                    })
                    
                    diff_hits = r2_weapon['hits'] - r1_weapon['hits']
                    diff_shots = r2_weapon['shots'] - r1_weapon['shots']
                    diff_kills = r2_weapon['kills'] - r1_weapon['kills']
                    diff_deaths = r2_weapon['deaths'] - r1_weapon['deaths']
                    diff_headshots = r2_weapon['headshots'] - r1_weapon['headshots']
                    
                    differential_player['weapon_stats'][weapon_name] = {
                        'hits': diff_hits,
                        'shots': diff_shots,
                        'kills': diff_kills,
                        'deaths': diff_deaths,
                        'headshots': diff_headshots,
                        'accuracy': (diff_hits / diff_shots * 100) if diff_shots > 0 else 0,
                    }

                # Calculate total shots/hits/accuracy for differential
                total_shots = sum(w['shots'] for w in differential_player['weapon_stats'].values())
                total_hits = sum(w['hits'] for w in differential_player['weapon_stats'].values())
                differential_player['total_shots'] = total_shots
                differential_player['total_hits'] = total_hits
                differential_player['total_accuracy'] = (total_hits / total_shots * 100) if total_shots > 0 else 0

                # Time differential
                r2_time = r2_player.get('time_played_seconds', 0)
                r1_time = r1_player.get('time_played_seconds', 0)
                differential_player['time_played_seconds'] = r2_time - r1_time

                # Calculate K/D ratio
                diff_kills = differential_player['kills']
                diff_deaths = differential_player['deaths']
                differential_player['kd_ratio'] = diff_kills / diff_deaths if diff_deaths > 0 else diff_kills

            else:
                # Player only in Round 2 - use their stats directly
                differential_player = r2_player.copy()

            # Calculate DPM for differential stats
            diff_seconds = differential_player.get('time_played_seconds', 0)
            if diff_seconds > 0:
                # DPM = (damage * 60) / seconds
                differential_player['dpm'] = (
                    differential_player['damage_given'] * 60
                ) / diff_seconds
            else:
                differential_player['dpm'] = 0.0

            # Calculate efficiency for differential stats
            total_kills = differential_player['kills']
            total_deaths = differential_player['deaths']
            differential_player['efficiency'] = (
                total_kills / (total_kills + total_deaths) * 100
                if (total_kills + total_deaths) > 0
                else 0
            )

            round_2_only_players.append(differential_player)

        # Calculate new MVP based on Round 2-only stats
        mvp = self.calculate_mvp(round_2_only_players)

        # Return Round 2-only result with proper metadata
        return {
            'success': True,
            'map_name': round_2_cumulative_data['map_name'],
            'round_num': 2,  # Always Round 2
            'map_time': round_2_cumulative_data['map_time'],
            'actual_time': round_2_cumulative_data['actual_time'],
            'round_outcome': round_2_cumulative_data['round_outcome'],
            'players': round_2_only_players,
            'mvp': mvp,
            'total_players': len(round_2_only_players),
            'timestamp': datetime.now().isoformat(),
            'differential_calculation': True,  # Flag to indicate this was calculated
        }

    def parse_regular_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file (original implementation)"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            if len(lines) < 2:
                return self._get_error_result("insufficient lines")

            # Parse header
            header_line = lines[0].strip()
            header_parts = header_line.split('\\')

            if len(header_parts) < 8:
                return self._get_error_result("invalid header format")

            header_parts[0]
            map_name = header_parts[1]
            header_parts[2]
            round_num = int(header_parts[3]) if header_parts[3].isdigit() else 1
            defender_team = int(header_parts[4]) if header_parts[4].isdigit() else 1
            winner_team = int(header_parts[5]) if header_parts[5].isdigit() else 0
            map_time = header_parts[6]
            actual_time = header_parts[7] if len(header_parts) > 7 else "Unknown"

            # Check for NEW lua format: 9th field = actual playtime in seconds
            actual_playtime_seconds = None
            if len(header_parts) >= 9:
                try:
                    # New format has exact playtime in seconds as 9th field
                    actual_playtime_seconds = float(header_parts[8])
                except (ValueError, IndexError):
                    actual_playtime_seconds = None

            # Parse players
            players = []
            for line in lines[1:]:
                if line.strip() and '\\' in line:
                    player_data = self.parse_player_line(line)
                    if player_data:
                        players.append(player_data)

            # Calculate time in SECONDS (primary storage format)
            if actual_playtime_seconds is not None:
                # NEW FORMAT: Use exact seconds from header field 9
                round_time_seconds = int(actual_playtime_seconds)
            else:
                # OLD FORMAT: Parse MM:SS from header field 8
                round_time_seconds = self.parse_time_to_seconds(actual_time)
                if round_time_seconds == 0:
                    round_time_seconds = 300  # Default 5 minutes if unknown

            # Calculate DPM for all players using SECONDS
            for player in players:
                damage_given = player.get('damage_given', 0)

                # Store time in SECONDS (integer)
                player['time_played_seconds'] = round_time_seconds

                # Create display format (MM:SS)
                minutes = round_time_seconds // 60
                seconds = round_time_seconds % 60
                player['time_display'] = f"{minutes}:{seconds:02d}"

                # Calculate DPM: (damage * 60) / seconds = damage per 60 seconds
                if round_time_seconds > 0:
                    player['dpm'] = (damage_given * 60) / round_time_seconds
                else:
                    player['dpm'] = 0.0

                # Backward compatibility: keep decimal minutes (deprecated)
                player['time_played_minutes'] = round_time_seconds / 60.0

            # Calculate MVP
            mvp = self.calculate_mvp(players)

            # Determine round outcome
            round_outcome = self.determine_round_outcome(map_time, actual_time, round_num)

            return {
                'success': True,
                'map_name': map_name,
                'round_num': round_num,
                'defender_team': defender_team,
                'winner_team': winner_team,
                'map_time': map_time,
                'actual_time': actual_time,
                'round_outcome': round_outcome,
                'players': players,
                'mvp': mvp,
                'total_players': len(players),
                'timestamp': datetime.now().isoformat(),
            }

        except Exception as e:
            print(f"‚ùå Error parsing stats file {file_path}: {e}")
            import traceback
            traceback.print_exc()
            return self._get_error_result(f"exception: {str(e)}")

    def parse_player_line(self, line: str) -> Optional[Dict[str, Any]]:
        """Parse a single player line using c0rnp0rn3.lua format"""
        try:
            # Split by backslash for basic info: guid\name\rounds\team\stats
            parts = line.split('\\')
            if len(parts) < 5:
                return None

            guid = parts[0]
            raw_name = parts[1]
            clean_name = self.strip_color_codes(raw_name)
            rounds = int(parts[2]) if parts[2].isdigit() else 0
            team = int(parts[3]) if parts[3].isdigit() else 0
            stats_section = parts[4]

            # Parse stats section using c0rnp0rn3 format
            # Split weapon stats (space-separated) from extended stats (TAB-separated)
            if '\t' in stats_section:
                weapon_section, extended_section = stats_section.split('\t', 1)
                stats_parts = weapon_section.split()
            else:
                stats_parts = stats_section.split()
                extended_section = None

            # Minimum validation: at least weapon mask (1 field) + 1 weapon (5 fields) = 6 fields
            # Changed from 30 to fix bug where players with fewer weapons were dropped
            if len(stats_parts) < 6:
                return None

            weapon_mask = int(stats_parts[0])

            # Extract weapon statistics using c0rnp0rn3 weapon mapping
            weapon_stats = {}
            total_kills = 0
            total_deaths = 0
            total_headshots = 0
            stats_index = 1  # Start after weapon mask

            # Process each weapon (0-27) using c0rnp0rn3 mapping
            for weapon_id in range(28):
                if weapon_mask & (1 << weapon_id):  # Check if weapon bit is set
                    weapon_name = C0RNP0RN3_WEAPONS.get(weapon_id, f"UNKNOWN_{weapon_id}")

                    if stats_index + 4 < len(stats_parts):
                        hits = int(stats_parts[stats_index])
                        shots = int(stats_parts[stats_index + 1])
                        kills = int(stats_parts[stats_index + 2])
                        deaths = int(stats_parts[stats_index + 3])
                        headshots = int(stats_parts[stats_index + 4])

                        accuracy = (hits / shots * 100) if shots > 0 else 0

                        weapon_stats[weapon_name] = {
                            'hits': hits,
                            'shots': shots,
                            'kills': kills,
                            'deaths': deaths,
                            'headshots': headshots,
                            'accuracy': accuracy,
                        }

                        total_kills += kills
                        total_deaths += deaths
                        total_headshots += headshots

                        stats_index += 5

            # Calculate additional metrics
            kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills

            # Calculate totals
            total_shots = sum(w['shots'] for w in weapon_stats.values())
            total_hits = sum(w['hits'] for w in weapon_stats.values())
            total_accuracy = (total_hits / total_shots * 100) if total_shots > 0 else 0

            # Extract additional stats (after weapon data)
            # After weapon stats come TAB-separated fields (0-35) = 36 fields
            additional_stats = {}
            objective_stats = {}  # NEW: Store objective/support stats

            if extended_section:
                # Extended stats are already TAB-separated
                tab_fields = extended_section.split('\t')

                # Actual format has 36 TAB-separated fields (per c0rnp0rn3.lua line 273)
                if len(tab_fields) >= 33:  # Full extended format
                    try:
                        # Basic stats - CORRECT field order from c0rnp0rn3.lua:
                        # 0: damageGiven, 1: damageReceived, 2: teamDamageGiven,
                        # 3: teamDamageReceived, 4: gibs, 5: selfkills,
                        # 6: teamkills, 7: teamgibs, 8: timePlayed
                        additional_stats = {
                            'damage_given': int(tab_fields[0]),
                            'damage_received': int(tab_fields[1]),
                            'team_damage_given': int(tab_fields[2]),
                            'team_damage_received': int(tab_fields[3]),
                            'gibs': int(tab_fields[4]),
                            'self_kills': int(tab_fields[5]),
                            'team_kills': int(tab_fields[6]),
                            'team_gibs': int(tab_fields[7]),
                            'time_played': float(tab_fields[8]),  # In minutes
                        }

                        # Objective/support stats (fields 9-32)
                        objective_stats = {
                            'health_given': int(tab_fields[9]),
                            'revives': int(tab_fields[10]),
                            'ammo_given': int(tab_fields[11]),
                            'construction': int(tab_fields[12]),
                            'demolition': int(tab_fields[13]),
                            'captures': int(tab_fields[14]),
                            'damage_team_given': int(tab_fields[15]),
                            'damage_team_received': int(tab_fields[16]),
                            'poison': int(tab_fields[17]),
                            'teleporter_travel': int(tab_fields[18]),
                            'teleporter_usage': int(tab_fields[19]),
                            'defused': int(tab_fields[20]),
                            'planted': int(tab_fields[21]),
                            'xp': float(tab_fields[22]),  # Total XP
                            'combatxp': float(tab_fields[23]),  # Combat XP
                            'time_axis': float(tab_fields[24]),  # Time on Axis
                            'time_allies': float(tab_fields[25]),  # Time on Allies
                            'multikill_2': int(tab_fields[26]),
                            'multikill_3': int(tab_fields[27]),
                            'multikill_4': int(tab_fields[28]),
                            'multikill_5': int(tab_fields[29]),
                            'best_spree': int(tab_fields[30]),
                            'denied': int(tab_fields[31]),
                            'deny_time': float(tab_fields[32]),
                        }
                    except (ValueError, IndexError) as e:
                        # If parsing fails, set defaults
                        print(f"‚ö†Ô∏è Warning: Failed to parse extended stats for {clean_name}: {e}")
                        additional_stats = {'damage_given': 0, 'damage_received': 0}
                        objective_stats = {}

            # Build player dictionary
            player = {
                'guid': guid,
                'name': clean_name,
                'rounds': rounds,
                'team': team,
                'kills': total_kills,
                'deaths': total_deaths,
                'headshots': total_headshots,
                'kd_ratio': kd_ratio,
                'total_shots': total_shots,
                'total_hits': total_hits,
                'total_accuracy': total_accuracy,
                'weapon_stats': weapon_stats,
                **additional_stats,
                **objective_stats,
            }

            return player

        except Exception as e:
            print(f"‚ö†Ô∏è Failed to parse player line: {e}")
            import traceback
            traceback.print_exc()
            return None


def test_c0rnporn3_parser():
    """Test the c0rnp0rn3 parser"""
    parser = C0RNP0RN3StatsParser()

    # Test all files in current directory
    test_files = glob.glob("*.txt")
    
    if not test_files:
        print("No test files found!")
        return

    for test_file in test_files:
        print(f"\n{'='*80}")
        print(f"Testing: {test_file}")
        print('='*80)
        
        result = parser.parse_stats_file(test_file)

        print(f"Success: {result['success']}")
        if result['success']:
            print(f"Map: {result['map_name']} Round {result['round_num']}")
            print(f"Players: {result['total_players']}")
            print(f"MVP: {result['mvp']['name'] if result['mvp'] else 'None'}")
            print(f"Outcome: {result['round_outcome']}")

            print("\nTop 3 Players by K/D:")
            sorted_players = sorted(result['players'], key=lambda x: x['kd_ratio'], reverse=True)
            for i, player in enumerate(sorted_players[:3], 1):
                print(
                    f"  {i}. {player['name']}: {player['kills']}K/{player['deaths']}D "
                    f"(K/D: {player['kd_ratio']:.2f}, Damage: {player.get('damage_given', 0)})"
                )
        else:
            print(f"Error: {result.get('error', 'Unknown error')}")


if __name__ == "__main__":
    test_c0rnporn3_parser()
