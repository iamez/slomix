#!/usr/bin/env python3
"""
EndStats.lua Format Parser
Parses end-of-round awards and VS stats from endstats.lua output files.

File format (tab-separated):
  Section 1 - Awards: Award Name\tPlayer Name\tValue
  Section 2 - VS Stats: Player Name\tKills\tDeaths
"""

import logging
import os
import re
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)

# =============================================================================
# FILENAME FORMAT: YYYY-MM-DD-HHMMSS-<map_name>-round-<N>-endstats.txt
# Example: 2026-01-12-224606-te_escape2-round-2-endstats.txt
#
# The timestamp matches the corresponding stats file:
# - 2026-01-12-224606-te_escape2-round-2.txt (main stats)
# - 2026-01-12-224606-te_escape2-round-2-endstats.txt (awards)
# =============================================================================

# Known award names from endstats.lua (for identification)
KNOWN_AWARDS = {
    "Most damage given",
    "Most damage received",
    "Most team damage given",
    "Most team damage received",
    "Most teamkills",
    "Most selfkills",
    "Most deaths",
    "Most kills per minute",
    "Quickest multikill w/ light weapons",
    "Farthest riflenade kill",
    "Most light weapon kills",
    "Most pistol kills",
    "Most rifle kills",
    "Most riflenade kills",
    "Most sniper kills",
    "Most knife kills",
    "Most air support kills",
    "Most mine kills",
    "Most grenade kills",
    "Most panzer kills",
    "Most mortar kills",
    "Most panzer deaths",
    "Mortarmagnet",
    "Most multikills",
    "Most MG42 kills",
    "Most MG42 deaths",
    "Most revives",
    "Most revived",
    "Best K/D ratio",
    "Most dynamites planted",
    "Most dynamites defused",
    "Most doublekills",
    "Longest killing spree",
    "Longest death spree",
    "Most objectives stolen",
    "Most objectives returned",
    "Most corpse gibs",
    "Most kill assists",
    "Most killsteals",
    "Most headshot kills",
    "Most damage per minute",
    "Tank/Meatshield (Refuses to die)",
    "Most useful kills (>Half respawn time left)",
    "Full respawn king",
    "Least time dead (What spawn?)",
    "Most playtime denied",
    "Most useless kills",
    "Highest light weapons accuracy",
    "Highest headshot accuracy",
    "Most headshots",
    "Most bullets fired",
}

# Award categories for embed organization
AWARD_CATEGORIES = {
    "combat": [
        "Most damage given",
        "Most damage received",
        "Most kills per minute",
        "Most damage per minute",
        "Best K/D ratio",
        "Tank/Meatshield (Refuses to die)",
    ],
    "deaths": [
        "Most deaths",
        "Most selfkills",
        "Most teamkills",
        "Longest death spree",
        "Most panzer deaths",
        "Most mortar deaths",
        "Most MG42 deaths",
        "Mortarmagnet",
    ],
    "skills": [
        "Most headshot kills",
        "Most headshots",
        "Highest light weapons accuracy",
        "Highest headshot accuracy",
        "Most light weapon kills",
        "Most pistol kills",
        "Most rifle kills",
        "Most sniper kills",
        "Most knife kills",
        "Longest killing spree",
        "Most multikills",
        "Most doublekills",
        "Quickest multikill w/ light weapons",
        "Most bullets fired",
    ],
    "weapons": [
        "Most grenade kills",
        "Most panzer kills",
        "Most mortar kills",
        "Most mine kills",
        "Most air support kills",
        "Most riflenade kills",
        "Farthest riflenade kill",
        "Most MG42 kills",
    ],
    "teamwork": [
        "Most revives",
        "Most revived",
        "Most kill assists",
        "Most killsteals",
        "Most team damage given",
        "Most team damage received",
    ],
    "objectives": [
        "Most dynamites planted",
        "Most dynamites defused",
        "Most objectives stolen",
        "Most objectives returned",
        "Most corpse gibs",
    ],
    "timing": [
        "Most useful kills (>Half respawn time left)",
        "Most useless kills",
        "Full respawn king",
        "Most playtime denied",
        "Least time dead (What spawn?)",
    ],
}


class EndStatsParser:
    """Parse endstats files generated by endstats.lua"""

    def __init__(self):
        """Initialize the endstats parser."""
        logger.debug("EndStatsParser initialized")

    def parse_filename(self, filename: str) -> Optional[Dict[str, Any]]:
        """
        Parse endstats filename to extract metadata.

        Args:
            filename: Filename like '2026-01-12-224606-te_escape2-round-2-endstats.txt'

        Returns:
            Dict with keys: date, time, map_name, round_number, match_id
            or None if filename doesn't match expected pattern
        """
        basename = os.path.basename(filename)

        # Pattern: YYYY-MM-DD-HHMMSS-mapname-round-N-endstats.txt
        pattern = r'^(\d{4})-(\d{2})-(\d{2})-(\d{6})-(.+)-round-(\d+)-endstats\.txt$'
        match = re.match(pattern, basename)

        if not match:
            logger.warning(f"Filename doesn't match endstats pattern: {basename}")
            return None

        year, month, day, time_str, map_name, round_num = match.groups()

        # Build match_id (same format as main stats files)
        date_str = f"{year}-{month}-{day}"
        match_id = f"{date_str}-{time_str}-{map_name}"

        return {
            'date': date_str,
            'time': time_str,
            'map_name': map_name,
            'round_number': int(round_num),
            'match_id': match_id,
            'filename': basename,
        }

    def parse_value(self, value_str: str) -> Tuple[str, Optional[float]]:
        """
        Parse award value string and extract numeric component.

        Args:
            value_str: Value like "3214", "1.78", "113 seconds", "50.47 percent"

        Returns:
            Tuple of (original_value, numeric_value)
        """
        value_str = value_str.strip()

        # Try to extract numeric part
        # Pattern: number followed by optional unit
        match = re.match(r'^([\d.]+)\s*(.*)$', value_str)

        if match:
            try:
                numeric = float(match.group(1))
                return (value_str, numeric)
            except ValueError:
                pass

        # Special case: "X kills in Y.YYs" format
        match = re.match(r'^(\d+)\s+kills\s+in\s+([\d.]+)s?$', value_str, re.IGNORECASE)
        if match:
            try:
                kills = int(match.group(1))
                return (value_str, float(kills))
            except ValueError:
                pass

        return (value_str, None)

    def parse_file(self, filepath: str) -> Optional[Dict[str, Any]]:
        """
        Parse an endstats file and return structured data.

        Args:
            filepath: Full path to the endstats file

        Returns:
            Dict with keys:
                - metadata: filename info (date, map, round, match_id)
                - awards: list of award dicts (name, player, value, numeric)
                - vs_stats: list of vs stat dicts (player, kills, deaths)
            or None on parse error
        """
        # Parse filename first
        metadata = self.parse_filename(filepath)
        if not metadata:
            return None

        awards = []
        vs_stats = []

        try:
            with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
                lines = f.readlines()
        except Exception as e:
            logger.error(f"Failed to read endstats file {filepath}: {e}")
            return None

        logger.info(f"Parsing endstats file: {filepath} ({len(lines)} lines)")

        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line:
                continue

            # Split by tab
            parts = line.split('\t')

            if len(parts) < 3:
                logger.debug(f"Line {line_num}: Skipping (less than 3 parts): {line[:50]}")
                continue

            # Determine if this is an award line or VS stats line
            first_part = parts[0].strip()

            # Check if first part is a known award name
            if first_part in KNOWN_AWARDS or any(first_part.startswith(award) for award in KNOWN_AWARDS):
                # Award line: Award Name | Player | Value
                award_name = first_part
                player_name = parts[1].strip()
                value_str = parts[2].strip()

                original_value, numeric_value = self.parse_value(value_str)

                awards.append({
                    'name': award_name,
                    'player': player_name,
                    'value': original_value,
                    'numeric': numeric_value,
                })
                logger.debug(f"Award: {award_name} -> {player_name} ({original_value})")

            else:
                # Try to parse as VS stats: Player | Kills | Deaths
                try:
                    player_name = first_part
                    kills = int(parts[1].strip())
                    deaths = int(parts[2].strip())

                    vs_stats.append({
                        'player': player_name,
                        'kills': kills,
                        'deaths': deaths,
                    })
                    logger.debug(f"VS Stats: {player_name} -> {kills}K/{deaths}D")

                except (ValueError, IndexError):
                    logger.debug(f"Line {line_num}: Could not parse as award or VS stats: {line[:50]}")
                    continue

        logger.info(f"Parsed {len(awards)} awards and {len(vs_stats)} VS stats entries")

        return {
            'metadata': metadata,
            'awards': awards,
            'vs_stats': vs_stats,
        }

    def categorize_awards(self, awards: List[Dict]) -> Dict[str, List[Dict]]:
        """
        Organize awards into categories for embed display.

        Args:
            awards: List of award dicts from parse_file()

        Returns:
            Dict mapping category name to list of awards in that category
        """
        categorized = {cat: [] for cat in AWARD_CATEGORIES.keys()}
        uncategorized = []

        for award in awards:
            award_name = award['name']
            found_category = False

            for category, category_awards in AWARD_CATEGORIES.items():
                if award_name in category_awards:
                    categorized[category].append(award)
                    found_category = True
                    break

            if not found_category:
                uncategorized.append(award)

        # Add uncategorized to 'other' if any
        if uncategorized:
            categorized['other'] = uncategorized

        # Remove empty categories
        return {k: v for k, v in categorized.items() if v}


def parse_endstats_file(filepath: str) -> Optional[Dict[str, Any]]:
    """
    Convenience function to parse an endstats file.

    Args:
        filepath: Path to the endstats file

    Returns:
        Parsed endstats data or None on error
    """
    parser = EndStatsParser()
    return parser.parse_file(filepath)


def validate_endstats_filename(filename: str) -> bool:
    """
    Validate that a filename matches the endstats pattern.

    Args:
        filename: Filename to validate

    Returns:
        True if valid endstats filename, False otherwise
    """
    basename = os.path.basename(filename)
    pattern = r'^(\d{4})-(\d{2})-(\d{2})-(\d{6})-([a-zA-Z0-9_-]+)-round-(\d+)-endstats\.txt$'
    return bool(re.match(pattern, basename))


# =============================================================================
# Testing
# =============================================================================
if __name__ == "__main__":
    import sys

    logging.basicConfig(level=logging.DEBUG)

    if len(sys.argv) > 1:
        filepath = sys.argv[1]
        result = parse_endstats_file(filepath)
        if result:
            print(f"\nMetadata: {result['metadata']}")
            print(f"\nAwards ({len(result['awards'])}):")
            for award in result['awards']:
                print(f"  {award['name']}: {award['player']} ({award['value']})")
            print(f"\nVS Stats ({len(result['vs_stats'])}):")
            for vs in result['vs_stats']:
                print(f"  {vs['player']}: {vs['kills']}K/{vs['deaths']}D")
        else:
            print("Failed to parse file")
    else:
        print("Usage: python endstats_parser.py <filepath>")
