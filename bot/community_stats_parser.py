#!/usr/bin/env python3
"""
C0RNP0RN3.LUA Format Parser
Correctly parses the actual weapon format used by c0rnp0rn3.lua
"""

import os
import re
from datetime import datetime
from typing import Any, Dict, List, Optional

import discord

# C0RNP0RN3.LUA weapon enumeration (the actual format used)
C0RNP0RN3_WEAPONS = {
    0: "WS_KNIFE",
    1: "WS_KNIFE_KBAR",
    2: "WS_LUGER",
    3: "WS_COLT",
    4: "WS_MP40",
    5: "WS_THOMPSON",
    6: "WS_STEN",
    7: "WS_FG42",
    8: "WS_PANZERFAUST",
    9: "WS_BAZOOKA",
    10: "WS_FLAMETHROWER",
    11: "WS_GRENADE",
    12: "WS_MORTAR",
    13: "WS_MORTAR2",
    14: "WS_DYNAMITE",
    15: "WS_AIRSTRIKE",
    16: "WS_ARTILLERY",
    17: "WS_SATCHEL",
    18: "WS_GRENADELAUNCHER",
    19: "WS_LANDMINE",
    20: "WS_MG42",
    21: "WS_BROWNING",
    22: "WS_CARBINE",
    23: "WS_KAR98",
    24: "WS_GARAND",
    25: "WS_K43",
    26: "WS_MP34",
    27: "WS_SYRINGE",
}


class C0RNP0RN3StatsParser:
    """Parse stats files generated by c0rnp0rn3.lua with stylish Discord formatting"""

    def __init__(self):
        # Weapon emojis for Discord formatting
        self.weapon_emojis = {
            'WS_MP40': 'üî´',
            'WS_THOMPSON': '‚ö°',
            'WS_LUGER': 'üéØ',
            'WS_COLT': 'üî∞',
            'WS_PANZERFAUST': 'üöÄ',
            'WS_GRENADELAUNCHER': 'üí•',
            'WS_GRENADE': 'üí£',
            'WS_KNIFE': 'üó°Ô∏è',
            'WS_SYRINGE': 'üíâ',
            'WS_FG42': 'üé™',
            'WS_KAR98': 'üéØ',
            'WS_GARAND': '‚≠ê',
            'WS_STEN': 'üîß',
        }

        self.team_colors = {1: 0xFF4444, 2: 0x4444FF}  # Axis - Red  # Allies - Blue

    def strip_color_codes(self, text: str) -> str:
        """Remove ET Legacy color codes from text (^0-^9, ^a-^z, etc.)"""
        if not text:
            return ""
        return re.sub(r'\^[0-9a-zA-Z]', '', text)

    def parse_time_to_seconds(self, time_str: str) -> int:
        """Convert time string (MM:SS or M:SS) to seconds"""
        try:
            if ':' in time_str:
                parts = time_str.split(':')
                minutes = int(parts[0])
                seconds = int(parts[1])
                return minutes * 60 + seconds
            else:
                return int(time_str)
        except BaseException:
            return 0

    def format_accuracy_bar(self, accuracy: float) -> str:
        """Create a visual accuracy bar with blocks"""
        filled = int(accuracy / 10)  # 10% per bar
        empty = 10 - filled
        return f"{'‚ñà' * filled}{'‚ñë' * empty} {accuracy:.1f}%"

    def format_kd_ratio(self, kills: int, deaths: int) -> str:
        """Format K/D ratio with performance indicators"""
        if deaths == 0:
            kd = kills
            indicator = "üî•"
        else:
            kd = kills / deaths
            if kd >= 2.0:
                indicator = "üî•"
            elif kd >= 1.5:
                indicator = "‚ö°"
            elif kd >= 1.0:
                indicator = "‚öîÔ∏è"
            else:
                indicator = "üìà"

        return f"{indicator} {kills}K/{deaths}D ({kd:.2f})"

    def create_stylish_round_embed(self, stats_data: Dict[str, Any]):
        """Create a beautiful Discord embed for round results"""

        map_name = stats_data.get('map_name', 'Unknown')
        round_num = stats_data.get('round_num', 1)
        outcome = stats_data.get('round_outcome', 'Unknown')
        mvp_name = stats_data.get('mvp', 'Unknown')
        players = stats_data.get('players', [])

        # Choose embed color based on outcome
        if outcome == 'Fullhold':
            color = 0xFF6B35  # Orange for fullhold
            outcome_emoji = '[D]'
        else:
            color = 0x00D2FF  # Blue for completed
            outcome_emoji = '[V]'

        embed = discord.Embed(
            title=f"[*] Round {round_num} Complete",
            description=f"**Map:** `{map_name}`\n{outcome_emoji} **Outcome:** {outcome}",
            color=color,
            timestamp=discord.utils.utcnow(),
        )

        # Add MVP section
        if mvp_name != 'Unknown' and players:
            mvp_player = next((p for p in players if p['name'] == mvp_name), None)
            if mvp_player:
                mvp_kd = self.format_kd_ratio(mvp_player['kills'], mvp_player['deaths'])
                mvp_dmg = mvp_player.get('damage_given', 0)

                embed.add_field(
                    name="üåü Round MVP",
                    value=f"**{mvp_name}**\n{mvp_kd}\nüíä {mvp_dmg} DMG",
                    inline=True,
                )

        # Add top performers with weapon highlights
        if players:
            sorted_players = sorted(players, key=lambda x: x['kd_ratio'], reverse=True)
            top_3 = sorted_players[:3]

            leaderboard = ""
            medals = ["ü•á", "ü•à", "ü•â"]

            for i, player in enumerate(top_3):
                medal = medals[i] if i < 3 else "üèÖ"
                kd_formatted = self.format_kd_ratio(player['kills'], player['deaths'])
                team_indicator = "üî¥" if player['team'] == 1 else "üîµ"

                # Get best SKILL weapon (exclude grenades, syringes, etc.)
                weapon_stats = player.get('weapon_stats', {})
                skill_weapons = [
                    'WS_MP40',
                    'WS_THOMPSON',
                    'WS_LUGER',
                    'WS_COLT',
                    'WS_STEN',
                    'WS_FG42',
                    'WS_KAR98',
                    'WS_GARAND',
                    'WS_CARBINE',
                    'WS_K43',
                ]
                best_weapon = None
                best_accuracy = 0

                for weapon, stats in weapon_stats.items():
                    if (
                        weapon in skill_weapons
                        and stats['shots'] > 5
                        and stats['accuracy'] > best_accuracy
                    ):
                        best_accuracy = stats['accuracy']
                        best_weapon = weapon

                weapon_info = ""
                if best_weapon:
                    emoji = self.weapon_emojis.get(best_weapon, 'üî´')
                    weapon_name = best_weapon.replace('WS_', '')
                    weapon_info = f"\n   {emoji} Topshots: {weapon_name} ({best_accuracy:.1f}%)"
                    # Use the accuracy bar for topshots
                    accuracy_bar = self.format_accuracy_bar(best_accuracy)
                    weapon_info = f"\n   {emoji} Topshots: {weapon_name}\n   {accuracy_bar}"

                leaderboard += f"{medal} {team_indicator} **{player['name']}**\n"
                leaderboard += f"   {kd_formatted}\n"
                leaderboard += f"   üíä {player.get('damage_given', 0)} DMG{weapon_info}\n\n"

            embed.add_field(name="üéØ Top Performers", value=leaderboard, inline=False)

        # Add match stats summary
        if players:
            total_kills = sum(p['kills'] for p in players)
            total_deaths = sum(p['deaths'] for p in players)
            avg_kd = total_kills / total_deaths if total_deaths > 0 else 0

            # Find weapon usage stats
            weapon_usage = {}
            for player in players:
                for weapon, stats in player.get('weapon_stats', {}).items():
                    if stats['shots'] > 0:
                        if weapon not in weapon_usage:
                            weapon_usage[weapon] = 0
                        weapon_usage[weapon] += stats['shots']

            # Most used weapon
            most_used = max(weapon_usage.items(), key=lambda x: x[1]) if weapon_usage else None
            weapon_info = ""
            if most_used:
                emoji = self.weapon_emojis.get(most_used[0], 'üî´')
                weapon_name = most_used[0].replace('WS_', '')
                weapon_info = f"\nüî´ Most Used: {emoji} {weapon_name}"

            embed.add_field(
                name="üìä Match Summary",
                value=f"üë• **{len(players)} Players**\n‚öîÔ∏è **{total_kills} Total Kills**\nüìà **{avg_kd:.2f} Avg K/D**{weapon_info}",
                inline=True,
            )

        embed.set_footer(text="ET:Legacy Community Stats ‚Ä¢ c0rnp0rn3.lua")

        return embed

    def create_detailed_player_stats(self, player: Dict[str, Any]) -> str:
        """Create detailed player stats in the beloved format"""

        name = player['name']
        team = player['team']
        kills = player['kills']
        deaths = player['deaths']
        kd_ratio = player['kd_ratio']
        headshots = player.get('headshots', 0)
        damage_given = player.get('damage_given', 0)
        damage_received = player.get('damage_received', 0)

        # Build the detailed stats string
        stats_text = f"üéØ {name} (Team {team})\n"
        stats_text += f"   Overall: {kills}K/{deaths}D (K/D: {kd_ratio:.2f})\n"
        stats_text += f"   Total Headshots: {headshots}\n"
        stats_text += f"   üíä Damage: {damage_given} dealt / {damage_received} received\n"

        # Add weapon performance section
        weapon_stats = player.get('weapon_stats', {})
        if weapon_stats:
            stats_text += "   üî´ Weapon Performance:\n"

            # Focus on key weapons
            focus_weapons = [
                'WS_MP40',
                'WS_THOMPSON',
                'WS_LUGER',
                'WS_COLT',
                'WS_PANZERFAUST',
                'WS_GRENADELAUNCHER',
            ]

            for weapon in focus_weapons:
                if weapon in weapon_stats:
                    w = weapon_stats[weapon]
                    if w['shots'] > 0 or w['kills'] > 0:
                        weapon_name = weapon.replace('WS_', '')
                        # Build a safe formatted line (avoid multi-line f-string that was broken)
                        stats_text += (
                            f"      {weapon_name}: {w['accuracy']:.1f}% acc "
                            f"({w['hits']}/{w['shots']}) | {w['kills']}K/{w['deaths']}D | {w['headshots']} HS\n"
                        )

        stats_text += "-" * 60
        return stats_text

    def parse_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file with Round 2 differential calculation"""
        try:
            # Check if this is a Round 2 file and needs differential calculation
            if self.is_round_2_file(file_path):
                return self.parse_round_2_with_differential(file_path)
            else:
                return self.parse_regular_stats_file(file_path)

        except Exception as e:
            print(f"[ERROR] Error parsing stats file {file_path}: {e}")
            return self._get_error_result(f"exception: {str(e)}")

    def is_round_2_file(self, file_path: str) -> bool:
        """Detect if this is a Round 2 file by filename pattern"""
        filename = os.path.basename(file_path)
        return "-round-2.txt" in filename

    def find_corresponding_round_1_file(self, round_2_file_path: str) -> Optional[str]:
        """Find the corresponding Round 1 file for a Round 2 file"""
        filename = os.path.basename(round_2_file_path)
        directory = os.path.dirname(round_2_file_path)

        # Extract date, map from Round 2 filename: YYYY-MM-DD-HHMMSS-mapname-round-2.txt
        parts = filename.split('-')
        if len(parts) < 6:
            return None

        date = '-'.join(parts[:3])  # YYYY-MM-DD
        map_name = '-'.join(parts[4:-2])  # everything between time and "round-2.txt"

        # Check both the same directory and local_stats directory
        search_dirs = [directory]
        if not directory.endswith("local_stats"):
            search_dirs.append("local_stats")

        potential_files = []
        
        # First, look for Round 1 files on the same date with the same map
        search_pattern = f"{date}-*-{map_name}-round-1.txt"
        for search_dir in search_dirs:
            if os.path.exists(search_dir):
                import glob
                pattern_path = os.path.join(search_dir, search_pattern)
                potential_files.extend(glob.glob(pattern_path))

        # ‚úÖ FIX: ALWAYS check previous date for midnight-crossing matches
        # (Don't just check if no same-day files found - we need to check both!)
        from datetime import datetime, timedelta
        try:
            date_obj = datetime.strptime(date, '%Y-%m-%d')
            prev_date = (date_obj - timedelta(days=1)).strftime('%Y-%m-%d')
            prev_search_pattern = f"{prev_date}-*-{map_name}-round-1.txt"
            
            print(f"  ‚Üí Checking previous date: {prev_search_pattern}")
            
            for search_dir in search_dirs:
                if os.path.exists(search_dir):
                    pattern_path = os.path.join(search_dir, prev_search_pattern)
                    found = glob.glob(pattern_path)
                    if found:
                        print(f"  ‚Üí Found {len(found)} files from previous date")
                    potential_files.extend(found)
        except ValueError:
            pass  # Invalid date format, skip previous date search

        if not potential_files:
            return None

        # Parse Round 2 full datetime for comparison
        from datetime import datetime
        try:
            r2_date_str = f"{date} {parts[3]}"  # "YYYY-MM-DD HHMMSS"
            r2_datetime = datetime.strptime(r2_date_str, '%Y-%m-%d %H%M%S')
        except (ValueError, IndexError):
            return None

        # Find the Round 1 file with the latest timestamp before Round 2
        best_r1_file = None
        best_r1_datetime = None

        for r1_file in potential_files:
            r1_filename = os.path.basename(r1_file)
            r1_parts = r1_filename.split('-')
            if len(r1_parts) >= 4:
                try:
                    r1_date = '-'.join(r1_parts[:3])  # YYYY-MM-DD
                    r1_time = r1_parts[3]  # HHMMSS
                    r1_date_str = f"{r1_date} {r1_time}"
                    r1_datetime = datetime.strptime(r1_date_str, '%Y-%m-%d %H%M%S')
                    
                    # Find the Round 1 file closest to but before Round 2
                    if r1_datetime < r2_datetime:
                        if best_r1_datetime is None or r1_datetime > best_r1_datetime:
                            best_r1_datetime = r1_datetime
                            best_r1_file = r1_file
                except ValueError:
                    continue

        return best_r1_file

    def parse_round_2_with_differential(self, round_2_file_path: str) -> Dict[str, Any]:
        """Parse Round 2 file with differential calculation to get Round 2-only stats"""
        print(f"[R2] Detected Round 2 file: {os.path.basename(round_2_file_path)}")

        # Find corresponding Round 1 file
        round_1_file_path = self.find_corresponding_round_1_file(round_2_file_path)
        if not round_1_file_path:
            print(f"[WARN] Could not find Round 1 file for {os.path.basename(round_2_file_path)}")
            print("   Parsing as regular file (cumulative stats will be included)")
            return self.parse_regular_stats_file(round_2_file_path)

        print(f"[R1] Found Round 1 file: {os.path.basename(round_1_file_path)}")

        # Parse both files
        round_1_result = self.parse_regular_stats_file(round_1_file_path)
        round_2_cumulative_result = self.parse_regular_stats_file(round_2_file_path)

        if not round_1_result['success'] or not round_2_cumulative_result['success']:
            print("[ERROR] Error parsing one of the round files")
            return self._get_error_result("failed to parse round files")

        # Calculate differential stats (Round 2 ONLY = Round 2 cumulative - Round 1)
        round_2_only_result = self.calculate_round_2_differential(
            round_1_result, round_2_cumulative_result
        )

        print(
            f"[OK] Successfully calculated Round 2-only stats for {len(round_2_only_result['players'])} players"
        )
        return round_2_only_result

    def calculate_round_2_differential(
        self, round_1_data: Dict[str, Any], round_2_cumulative_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Calculate Round 2-only stats by subtracting Round 1 from Round 2 cumulative"""

        # Create player lookup for Round 1 stats
        round_1_players = {player['name']: player for player in round_1_data['players']}

        round_2_only_players = []

        for r2_player in round_2_cumulative_data['players']:
            player_name = r2_player['name']
            r1_player = round_1_players.get(player_name)

            if not r1_player:
                # Player only in Round 2, use cumulative stats as-is
                round_2_only_players.append(r2_player.copy())
                continue

            # Calculate differential for this player
            differential_player = {
                # FIX: Include GUID for database operations
                'guid': r2_player.get('guid', 'UNKNOWN'),
                'name': player_name,
                'team': r2_player['team'],
                'kills': max(0, r2_player['kills'] - r1_player['kills']),
                'deaths': max(0, r2_player['deaths'] - r1_player['deaths']),
                'headshots': max(0, r2_player.get('headshots', 0) - r1_player.get('headshots', 0)),
                'damage_given': max(
                    0, r2_player.get('damage_given', 0) - r1_player.get('damage_given', 0)
                ),
                'damage_received': max(
                    0, r2_player.get('damage_received', 0) - r1_player.get('damage_received', 0)
                ),
                'weapon_stats': {},
                'objective_stats': {},  # Will populate below
            }

            # FIX: Preserve objective_stats from Round 2 cumulative (includes time!)
            # For Round 2, we want the differential of objective stats
            r2_obj = r2_player.get('objective_stats', {})
            r1_obj = r1_player.get('objective_stats', {})

            # Calculate differential objective stats
            for key in r2_obj:
                if key == 'time_played_minutes':
                    # CRITICAL: For time, use R2 cumulative minus R1
                    # This gives us the time played ONLY in Round 2
                    r2_time = r2_obj.get('time_played_minutes', 0)
                    r1_time = r1_obj.get('time_played_minutes', 0)
                    diff_minutes = max(0, r2_time - r1_time)
                    differential_player['objective_stats']['time_played_minutes'] = diff_minutes
                elif isinstance(r2_obj[key], (int, float)):
                    # For numeric fields, calculate differential
                    differential_player['objective_stats'][key] = max(
                        0, r2_obj.get(key, 0) - r1_obj.get(key, 0)
                    )
                else:
                    # For non-numeric, use R2 value
                    differential_player['objective_stats'][key] = r2_obj[key]

            # NEW: Calculate time in SECONDS for R2 differential
            # Use time from objective_stats (lua-rounded minutes)
            diff_minutes = differential_player['objective_stats'].get('time_played_minutes', 0)
            diff_seconds = int(diff_minutes * 60)  # Convert minutes to seconds

            differential_player['time_played_seconds'] = diff_seconds
            differential_player['time_played_minutes'] = diff_minutes  # Backward compat

            # Create time_display (MM:SS format)
            minutes = diff_seconds // 60
            seconds = diff_seconds % 60
            differential_player['time_display'] = f"{minutes}:{seconds:02d}"

            # Calculate differential weapon stats
            for weapon_name, r2_weapon in r2_player.get('weapon_stats', {}).items():
                r1_weapon = r1_player.get('weapon_stats', {}).get(
                    weapon_name, {'hits': 0, 'shots': 0, 'kills': 0, 'deaths': 0, 'headshots': 0}
                )

                differential_weapon = {
                    'hits': max(0, r2_weapon['hits'] - r1_weapon['hits']),
                    'shots': max(0, r2_weapon['shots'] - r1_weapon['shots']),
                    'kills': max(0, r2_weapon['kills'] - r1_weapon['kills']),
                    'deaths': max(0, r2_weapon['deaths'] - r1_weapon['deaths']),
                    'headshots': max(0, r2_weapon['headshots'] - r1_weapon['headshots']),
                }

                # Calculate accuracy for differential stats
                if differential_weapon['shots'] > 0:
                    differential_weapon['accuracy'] = (
                        differential_weapon['hits'] / differential_weapon['shots']
                    ) * 100
                else:
                    differential_weapon['accuracy'] = 0.0

                differential_player['weapon_stats'][weapon_name] = differential_weapon

            # Calculate K/D ratio for differential stats
            if differential_player['deaths'] > 0:
                differential_player['kd_ratio'] = (
                    differential_player['kills'] / differential_player['deaths']
                )
            else:
                differential_player['kd_ratio'] = differential_player['kills']

            # Calculate DPM using R2 differential time (in SECONDS!)
            diff_seconds = differential_player.get('time_played_seconds', 0)
            if diff_seconds > 0:
                # DPM = (damage * 60) / seconds
                differential_player['dpm'] = (
                    differential_player['damage_given'] * 60
                ) / diff_seconds
            else:
                differential_player['dpm'] = 0.0

            # Calculate efficiency for differential stats
            total_kills = differential_player['kills']
            total_deaths = differential_player['deaths']
            differential_player['efficiency'] = (
                total_kills / (total_kills + total_deaths) * 100
                if (total_kills + total_deaths) > 0
                else 0
            )

            # Calculate overall accuracy from weapon stats differential
            total_hits = sum(w.get('hits', 0) for w in differential_player['weapon_stats'].values())
            total_shots = sum(w.get('shots', 0) for w in differential_player['weapon_stats'].values())
            differential_player['accuracy'] = (total_hits / total_shots * 100) if total_shots > 0 else 0.0
            differential_player['shots_total'] = total_shots
            differential_player['hits_total'] = total_hits

            # FIX: Recalculate time_dead for Round 2 differential
            # time_dead_ratio should be based on Round 2-only time, not subtracted percentages
            diff_time_seconds = differential_player.get('time_played_seconds', 0)
            if diff_time_seconds > 0:
                # Get time_dead_minutes from objective_stats differential
                time_dead_mins = differential_player['objective_stats'].get('time_dead_minutes', 0)
                # Calculate ratio as percentage
                time_dead_ratio = (time_dead_mins / (diff_time_seconds / 60.0) * 100) if diff_time_seconds > 0 else 0
                differential_player['objective_stats']['time_dead_ratio'] = time_dead_ratio

            round_2_only_players.append(differential_player)

        # Calculate new MVP based on Round 2-only stats
        mvp = self.calculate_mvp(round_2_only_players)

        # Return Round 2-only result with proper metadata
        return {
            'success': True,
            'map_name': round_2_cumulative_data['map_name'],
            'round_num': 2,  # Always Round 2
            'map_time': round_2_cumulative_data['map_time'],
            'actual_time': round_2_cumulative_data['actual_time'],
            'round_outcome': round_2_cumulative_data['round_outcome'],
            'players': round_2_only_players,
            'mvp': mvp,
            'total_players': len(round_2_only_players),
            'timestamp': datetime.now().isoformat(),
            'differential_calculation': True,  # Flag to indicate this was calculated
        }

    def parse_regular_stats_file(self, file_path: str) -> Dict[str, Any]:
        """Parse c0rnp0rn3.lua stats file (original implementation)"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()

            if len(lines) < 2:
                return self._get_error_result("insufficient lines")

            # Parse header
            header_line = lines[0].strip()
            header_parts = header_line.split('\\')

            if len(header_parts) < 8:
                return self._get_error_result("invalid header format")

            header_parts[0]
            map_name = header_parts[1]
            header_parts[2]
            round_num = int(header_parts[3]) if header_parts[3].isdigit() else 1
            defender_team = int(header_parts[4]) if len(header_parts) > 4 and header_parts[4].isdigit() else 1
            winner_team = int(header_parts[5]) if len(header_parts) > 5 and header_parts[5].isdigit() else 0
            map_time = header_parts[6]
            actual_time = header_parts[7] if len(header_parts) > 7 else "Unknown"

            # Check for NEW lua format: 9th field = actual playtime in seconds
            actual_playtime_seconds = None
            if len(header_parts) >= 9:
                try:
                    # New format has exact playtime in seconds as 9th field
                    actual_playtime_seconds = float(header_parts[8])
                except (ValueError, IndexError):
                    actual_playtime_seconds = None

            # Parse players
            players = []
            for line in lines[1:]:
                if line.strip() and '\\' in line:
                    player_data = self.parse_player_line(line)
                    if player_data:
                        players.append(player_data)

            # Calculate time in SECONDS (primary storage format)
            if actual_playtime_seconds is not None:
                # NEW FORMAT: Use exact seconds from header field 9
                round_time_seconds = int(actual_playtime_seconds)
            else:
                # OLD FORMAT: Parse MM:SS from header field 8
                round_time_seconds = self.parse_time_to_seconds(actual_time)
                if round_time_seconds == 0:
                    round_time_seconds = 300  # Default 5 minutes if unknown

            # Calculate DPM for all players using SECONDS
            for player in players:
                damage_given = player.get('damage_given', 0)

                # Store time in SECONDS (integer)
                player['time_played_seconds'] = round_time_seconds

                # Create display format (MM:SS)
                minutes = round_time_seconds // 60
                seconds = round_time_seconds % 60
                player['time_display'] = f"{minutes}:{seconds:02d}"

                # Calculate DPM: (damage * 60) / seconds = damage per 60 seconds
                if round_time_seconds > 0:
                    player['dpm'] = (damage_given * 60) / round_time_seconds
                else:
                    player['dpm'] = 0.0

                # Backward compatibility: keep decimal minutes (deprecated)
                player['time_played_minutes'] = round_time_seconds / 60.0

            # Calculate MVP
            mvp = self.calculate_mvp(players)

            # Determine round outcome
            round_outcome = self.determine_round_outcome(map_time, actual_time, round_num)

            return {
                'success': True,
                'map_name': map_name,
                'round_num': round_num,
                'defender_team': defender_team,
                'winner_team': winner_team,
                'map_time': map_time,
                'actual_time': actual_time,
                'round_outcome': round_outcome,
                'players': players,
                'mvp': mvp,
                'total_players': len(players),
                'timestamp': datetime.now().isoformat(),
            }

        except Exception as e:
            print(f"[ERROR] Error parsing stats file {file_path}: {e}")
            return self._get_error_result(f"exception: {str(e)}")

    def parse_player_line(self, line: str) -> Optional[Dict[str, Any]]:
        """Parse a single player line using c0rnp0rn3.lua format"""
        try:
            # Split by backslash for basic info: guid\name\rounds\team\stats
            parts = line.split('\\')
            if len(parts) < 5:
                return None

            guid = parts[0]
            raw_name = parts[1]
            clean_name = self.strip_color_codes(raw_name)
            rounds = int(parts[2]) if parts[2].isdigit() else 0
            team = int(parts[3]) if parts[3].isdigit() else 0
            stats_section = parts[4]

            # Parse stats section using c0rnp0rn3 format
            # Split weapon stats (space-separated) from extended stats (TAB-separated)
            if '\t' in stats_section:
                weapon_section, extended_section = stats_section.split('\t', 1)
                stats_parts = weapon_section.split()
            else:
                stats_parts = stats_section.split()
                extended_section = None

            # Minimum validation: at least weapon mask (1 field) + 1 weapon (5 fields) = 6 fields
            # Changed from 30 to fix bug where players with fewer weapons were dropped
            if len(stats_parts) < 6:
                return None

            weapon_mask = int(stats_parts[0])

            # Extract weapon statistics using c0rnp0rn3 weapon mapping
            weapon_stats = {}
            total_kills = 0
            total_deaths = 0
            total_headshots = 0
            stats_index = 1  # Start after weapon mask

            # Process each weapon (0-27) using c0rnp0rn3 mapping
            for weapon_id in range(28):
                if weapon_mask & (1 << weapon_id):  # Check if weapon bit is set
                    weapon_name = C0RNP0RN3_WEAPONS.get(weapon_id, f"UNKNOWN_{weapon_id}")

                    if stats_index + 4 < len(stats_parts):
                        hits = int(stats_parts[stats_index])
                        shots = int(stats_parts[stats_index + 1])
                        kills = int(stats_parts[stats_index + 2])
                        deaths = int(stats_parts[stats_index + 3])
                        headshots = int(stats_parts[stats_index + 4])

                        accuracy = (hits / shots * 100) if shots > 0 else 0

                        weapon_stats[weapon_name] = {
                            'hits': hits,
                            'shots': shots,
                            'kills': kills,
                            'deaths': deaths,
                            'headshots': headshots,
                            'accuracy': accuracy,
                        }

                        total_kills += kills
                        total_deaths += deaths
                        total_headshots += headshots

                        stats_index += 5

            # Calculate additional metrics
            kd_ratio = total_kills / total_deaths if total_deaths > 0 else total_kills

            # Calculate totals
            total_shots = sum(w['shots'] for w in weapon_stats.values())
            total_hits = sum(w['hits'] for w in weapon_stats.values())
            total_accuracy = (total_hits / total_shots * 100) if total_shots > 0 else 0

            # Extract additional stats (after weapon data)
            # After weapon stats come TAB-separated fields (0-35) = 36 fields
            additional_stats = {}
            objective_stats = {}  # NEW: Store objective/support stats

            if extended_section:
                # Extended stats are already TAB-separated
                tab_fields = extended_section.split('\t')

                # Helper: safe cast functions to avoid IndexError/ValueError
                def safe_int(lst, idx, default=0):
                    try:
                        return int(lst[idx])
                    except Exception:
                        return default

                def safe_float(lst, idx, default=0.0):
                    try:
                        return float(lst[idx])
                    except Exception:
                        return default

                # Populate additional_stats and objective_stats using safe accessors
                try:
                    additional_stats = {
                        'damage_given': safe_int(tab_fields, 0),
                        'damage_received': safe_int(tab_fields, 1),
                        'team_damage_given': safe_int(tab_fields, 2),
                        'team_damage_received': safe_int(tab_fields, 3),
                        'gibs': safe_int(tab_fields, 4),
                        'self_kills': safe_int(tab_fields, 5),
                        'team_kills': safe_int(tab_fields, 6),
                        'team_gibs': safe_int(tab_fields, 7),
                        'time_played_percent': safe_float(tab_fields, 8),
                    }

                    objective_stats = {
                        'damage_given': safe_int(tab_fields, 0),
                        'damage_received': safe_int(tab_fields, 1),
                        'team_damage_given': safe_int(tab_fields, 2),
                        'team_damage_received': safe_int(tab_fields, 3),
                        'gibs': safe_int(tab_fields, 4),
                        'self_kills': safe_int(tab_fields, 5),
                        'team_kills': safe_int(tab_fields, 6),
                        'team_gibs': safe_int(tab_fields, 7),
                        'time_played_percent': safe_float(tab_fields, 8),
                        'xp': safe_int(tab_fields, 9),
                        'killing_spree': safe_int(tab_fields, 10),
                        'death_spree': safe_int(tab_fields, 11),
                        'kill_assists': safe_int(tab_fields, 12),
                        'kill_steals': safe_int(tab_fields, 13),
                        'headshot_kills': safe_int(tab_fields, 14),
                        'objectives_stolen': safe_int(tab_fields, 15),
                        'objectives_returned': safe_int(tab_fields, 16),
                        'dynamites_planted': safe_int(tab_fields, 17),
                        'dynamites_defused': safe_int(tab_fields, 18),
                        'times_revived': safe_int(tab_fields, 19),
                        'bullets_fired': safe_int(tab_fields, 20),
                        'dpm': safe_float(tab_fields, 21),
                        'time_played_minutes': safe_float(tab_fields, 22),
                        'tank_meatshield': safe_float(tab_fields, 23),
                        'time_dead_ratio': safe_float(tab_fields, 24),
                        'time_dead_minutes': safe_float(tab_fields, 25),
                        'kd_ratio': safe_float(tab_fields, 26),
                        'useful_kills': safe_int(tab_fields, 27),
                        'denied_playtime': safe_int(tab_fields, 28),
                        'multikill_2x': safe_int(tab_fields, 29),
                        'multikill_3x': safe_int(tab_fields, 30),
                        'multikill_4x': safe_int(tab_fields, 31),
                        'multikill_5x': safe_int(tab_fields, 32),
                        'multikill_6x': safe_int(tab_fields, 33),
                        'useless_kills': safe_int(tab_fields, 34),
                        'full_selfkills': safe_int(tab_fields, 35),
                        'repairs_constructions': safe_int(tab_fields, 36),
                        'revives_given': safe_int(tab_fields, 37),
                    }
                except Exception as e:
                    # Defensive fallback: ensure we always have at least basic numbers
                    print(f"Warning: Could not fully parse extended fields, falling back: {e}")
                    additional_stats = {
                        'damage_given': safe_int(tab_fields, 0),
                        'damage_received': safe_int(tab_fields, 1),
                    }

            # Calculate efficiency
            efficiency = 0
            if (total_kills + total_deaths) > 0:
                efficiency = total_kills / (total_kills + total_deaths) * 100

            return {
                'guid': guid[:8],  # Truncate GUID
                'clean_name': clean_name,  # ‚úÖ FIXED: Use clean_name
                'name': clean_name,  # Keep both for compatibility
                'raw_name': raw_name,
                'team': team,
                'rounds': rounds,
                'kills': total_kills,
                'deaths': total_deaths,
                'headshots': total_headshots,  # ‚ö†Ô∏è IMPORTANT: This is sum of weapon headshot HITS (not kills!)
                'kd_ratio': kd_ratio,
                'shots_total': total_shots,
                'hits_total': total_hits,
                'accuracy': total_accuracy,
                'damage_given': additional_stats.get('damage_given', 0),
                'damage_received': additional_stats.get('damage_received', 0),
                'dpm': objective_stats.get('dpm', 0.0),
                'weapon_stats': weapon_stats,
                'efficiency': efficiency,
                'objective_stats': objective_stats,  # ‚úÖ Contains headshot_KILLS (TAB field 14) + revives + all other stats
            }
            
            # ‚ö†Ô∏è CRITICAL DISTINCTION - DO NOT CONFUSE THESE TWO:
            # 1. player['headshots'] = Sum of all weapon headshot HITS (shots that hit head, may not kill)
            # 2. objective_stats['headshot_kills'] = TAB field 14 (kills where FINAL BLOW was to head)
            # These are DIFFERENT stats! Database stores headshot_kills, NOT weapon sum.
            # Validated Nov 3, 2025: 100% accuracy confirmed.

        except Exception as e:
            print(f"Error parsing player line: {e}")
            return None

    def calculate_mvp(self, players: List[Dict[str, Any]]) -> Optional[str]:
        """Calculate MVP based on K/D ratio, efficiency, and damage"""
        if not players:
            return None

        best_player = None
        best_score = 0

        for player in players:
            # MVP scoring: K/D ratio + efficiency + damage factor
            kd_score = player['kd_ratio'] * 10
            efficiency_score = player['efficiency']
            damage_score = player['damage_given'] / 100

            total_score = kd_score + efficiency_score + damage_score

            if total_score > best_score:
                best_score = total_score
                best_player = player

        return best_player['name'] if best_player else None

    def determine_round_outcome(self, map_time: str, actual_time: str, round_num: int) -> str:
        """Determine if round was fullhold based on time comparison

        NOTE: In Round 2, actual_time of "0:00" appears in 19.6% of files.
        This likely indicates the g_nextTimeLimit cvar was reset/not set.
        We treat this as "Unknown" to preserve data integrity.
        See dev/TIME_FORMAT_ANALYSIS.md for details.
        """
        try:
            map_seconds = self.parse_time_to_seconds(map_time)
            actual_seconds = (
                self.parse_time_to_seconds(actual_time) if actual_time != "Unknown" else 600
            )

            # Special case: Round 2 with 0:00 actual_time
            # This appears in ~20% of Round 2 files, meaning unclear
            if round_num == 2 and actual_time == "0:00":
                return "Unknown"

            time_diff = map_seconds - actual_seconds

            if time_diff <= 30:  # Within 30 seconds = time ran out
                return "Fullhold"
            else:
                return "Completed"

        except BaseException:
            return "Unknown"

    def _get_error_result(self, error_type: str) -> Dict[str, Any]:
        """Return standardized error result"""
        return {
            'success': False,
            'error': error_type,
            'map_name': 'Unknown',
            'round_num': 0,
            'players': [],
            'mvp': None,
            'total_players': 0,
            'timestamp': datetime.now().isoformat(),
        }


def test_c0rnporn3_parser():
    """Test the c0rnp0rn3 parser"""
    parser = C0RNP0RN3StatsParser()

    test_file = "2025-09-30-220944-etl_sp_delivery-round-2.txt"
    result = parser.parse_stats_file(test_file)

    print("=== C0RNP0RN3.LUA Parser Test ===")
    print(f"Success: {result['success']}")
    print(f"Map: {result['map_name']} Round {result['round_num']}")
    print(f"Players: {result['total_players']}")
    print(f"MVP: {result['mvp']}")
    print(f"Outcome: {result['round_outcome']}")

    print("\nTop 3 Players:")
    sorted_players = sorted(result['players'], key=lambda x: x['kd_ratio'], reverse=True)
    for i, player in enumerate(sorted_players[:3], 1):
        print(
            f"  {i}. {player['name']}: {player['kills']}K/{player['deaths']}D (K/D: {player['kd_ratio']:.2f})"
        )

        # Show weapon breakdown for MP40/Thompson/Luger/Colt
        focus_weapons = ['WS_MP40', 'WS_THOMPSON', 'WS_LUGER', 'WS_COLT']
        for weapon in focus_weapons:
            if weapon in player['weapon_stats']:
                w = player['weapon_stats'][weapon]
                if w['shots'] > 0:
                    weapon_name = weapon.replace('WS_', '')
                    print(
                        (
                            f"     {weapon_name}: {w['accuracy']:.1f}% acc "
                            f"({w['hits']}/{w['shots']}) | {w['kills']}K/{w['deaths']}D | {w['headshots']} HS"
                        )
                    )


if __name__ == "__main__":
    test_c0rnporn3_parser()
