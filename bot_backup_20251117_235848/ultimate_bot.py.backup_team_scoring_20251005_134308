#!/usr/bin/env python3
"""
üöÄ ULTIMATE ET:LEGACY DISCORD BOT - COG-BASED VERSION
====================================================

Fixed version using proper Cog patt          embed.add_field(
            name="üìä Stats Commands",
            value=(
                "‚Ä¢ `!stats [player]` - Player statistics\\n"
                "‚Ä¢ `!leaderboard [type]` - Rankings (kills/kd/dpm/acc/hs)\\n"
                "‚Ä¢ `!session [date]` - Match details"
            ),
            inline=False
        )

        embed.add_field(
            name="üîó Account",
            value="‚Ä¢ `!link <name>` - Link your account\\n‚Ä¢ `!unlink` - Unlink",
            inline=False
        )

        embed.add_field(
            name="üîß System",
            value="‚Ä¢ `!ping` - Bot status\\n‚Ä¢ `!session_start/end` - Manage sessions",
            inline=False
        )

        await ctx.send(embed=embed)ld(
            name="üìä Stats Commands",
            value=(
                "‚Ä¢ `!stats [player]` - Player statistics\\n"
                "‚Ä¢ `!leaderboard [type]` - Top players (kills/kd/dpm/acc/hs)\\n"
                "‚Ä¢ `!session [date]` - Session details"
            ),
            inline=False
        )or discord.py 2.3.x
All commands now properly register and work correctly.
"""

import asyncio
import datetime
import logging
import os
import time
from datetime import datetime

import aiosqlite
import discord
from discord.ext import commands, tasks

# Load environment variables
try:
    from dotenv import load_dotenv

    load_dotenv()
except ImportError:
    print("‚ö†Ô∏è  python-dotenv not installed. Using environment variables directly.")

# Setup comprehensive logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/ultimate_bot.log', encoding='utf-8'),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger('UltimateBot')


class ETLegacyCommands(commands.Cog):
    """üéÆ ET:Legacy Bot Commands Cog"""

    def __init__(self, bot):
        self.bot = bot

    # üéÆ SESSION MANAGEMENT COMMANDS

    @commands.command(name='session_start')
    async def session_start(self, ctx, *, map_name: str = "Unknown"):
        """üé¨ Start a new gaming session"""
        try:
            if self.bot.current_session:
                await ctx.send("‚ùå A session is already active. End it first with `!session_end`")
                return

            now = datetime.now()
            date_str = now.strftime('%Y-%m-%d')
            time_str = now.strftime('%H:%M:%S')

            async with aiosqlite.connect(self.bot.db_path) as db:
                cursor = await db.execute(
                    '''
                    INSERT INTO sessions (start_time, date, map_name, status)
                    VALUES (?, ?, ?, 'active')
                ''',
                    (time_str, date_str, map_name),
                )

                session_id = cursor.lastrowid
                self.bot.current_session = session_id
                await db.commit()

            embed = discord.Embed(
                title="üé¨ Session Started!",
                description=f"**Map:** {map_name}\\n**Started:** {time_str}\\n**Session ID:** {session_id}",
                color=0x00FF00,
                timestamp=now,
            )
            await ctx.send(embed=embed)
            logger.info(f"Session {session_id} started on {map_name}")

        except Exception as e:
            logger.error(f"Error starting session: {e}")
            await ctx.send(f"‚ùå Error starting session: {e}")

    @commands.command(name='session_end')
    async def session_end(self, ctx):
        """üèÅ End the current gaming session"""
        try:
            if not self.bot.current_session:
                await ctx.send("‚ùå No active session to end.")
                return

            now = datetime.now()
            time_str = now.strftime('%H:%M:%S')

            async with aiosqlite.connect(self.bot.db_path) as db:
                # Update session end time
                await db.execute(
                    '''
                    UPDATE sessions
                    SET end_time = ?, status = 'completed'
                    WHERE id = ?
                ''',
                    (time_str, self.bot.current_session),
                )

                # Get session stats
                async with db.execute(
                    '''
                    SELECT COUNT(*) as rounds, map_name, start_time
                    FROM sessions s
                    LEFT JOIN player_stats ps ON s.id = ps.session_id
                    WHERE s.id = ?
                ''',
                    (self.bot.current_session,),
                ) as cursor:
                    session_data = await cursor.fetchone()

                await db.commit()

            embed = discord.Embed(
                title="üèÅ Session Ended!",
                description=f"**Session ID:** {
                    self.bot.current_session}\\n**Duration:** {
                    session_data[2]} - {time_str}\\n**Rounds Played:** {
                    session_data[0] or 0}",
                color=0xFF0000,
                timestamp=now,
            )

            self.bot.current_session = None
            await ctx.send(embed=embed)
            logger.info(f"Session ended at {time_str}")

        except Exception as e:
            logger.error(f"Error ending session: {e}")
            await ctx.send(f"‚ùå Error ending session: {e}")

    @commands.command(name='ping')
    async def ping(self, ctx):
        """üèì Check bot status and performance"""
        try:
            start_time = time.time()

            # Test database connection
            async with aiosqlite.connect(self.bot.db_path) as db:
                await db.execute('SELECT 1')

            db_latency = (time.time() - start_time) * 1000

            embed = discord.Embed(title="üèì Ultimate Bot Status", color=0x00FF00)
            embed.add_field(
                name="Bot Latency",
                value=f"{
                    round(
                        self.bot.latency *
                        1000)}ms",
                inline=True,
            )
            embed.add_field(name="DB Latency", value=f"{round(db_latency)}ms", inline=True)
            embed.add_field(
                name="Active Session",
                value="Yes" if self.bot.current_session else "No",
                inline=True,
            )
            embed.add_field(name="Commands", value=f"{len(list(self.bot.commands))}", inline=True)

            await ctx.send(embed=embed)

        except Exception as e:
            logger.error(f"Error in ping command: {e}")
            await ctx.send(f"‚ùå Bot error: {e}")

    @commands.command(name='help_command')
    async def help_command(self, ctx):
        """üìö Show all available commands"""
        embed = discord.Embed(
            title="üöÄ Ultimate ET:Legacy Bot Commands",
            description="**Use `!` prefix for all commands** (e.g., `!ping`, not `/ping`)",
            color=0x0099FF,
        )

        embed.add_field(
            name="üé¨ Session Management",
            value="‚Ä¢ `!session_start [map]` - Start new session\\n‚Ä¢ `!session_end` - End current session",
            inline=False,
        )

        embed.add_field(
            name="ÔøΩ Stats Commands",
            value="‚Ä¢ `!stats [player]` - Player statistics\\n‚Ä¢ `!leaderboard [type]` - Top players\\n‚Ä¢ `!session [date]` - Session details",
            inline=False,
        )

        embed.add_field(
            name="ÔøΩüîß System",
            value="‚Ä¢ `!ping` - Bot status\\n‚Ä¢ `!help_command` - This help",
            inline=False,
        )

        await ctx.send(embed=embed)

    @commands.command(name='stats')
    async def stats(self, ctx, *, player_name: str = None):
        """üìä Show detailed player statistics
        
        Usage:
        - !stats              ‚Üí Your stats (if linked)
        - !stats playerName   ‚Üí Search by name
        - !stats @user        ‚Üí Stats for mentioned Discord user
        """
        try:
            player_guid = None
            primary_name = None
            
            # Open ONE database connection for the entire command
            async with aiosqlite.connect(self.bot.db_path) as db:
                # === SCENARIO 1: @MENTION - Look up linked Discord user ===
                if ctx.message.mentions:
                    mentioned_user = ctx.message.mentions[0]
                    mentioned_id = str(mentioned_user.id)
                    
                    async with db.execute(
                        '''
                        SELECT et_guid, et_name FROM player_links
                        WHERE discord_id = ?
                    ''',
                        (mentioned_id,),
                    ) as cursor:
                        link = await cursor.fetchone()
                    
                    if not link:
                        # User not linked - helpful message
                        embed = discord.Embed(
                            title="‚ö†Ô∏è Account Not Linked",
                            description=(
                                f"{mentioned_user.mention} hasn't linked their "
                                f"ET:Legacy account yet!"
                            ),
                            color=0xFFA500,
                        )
                        embed.add_field(
                            name="How to Link",
                            value=(
                                "‚Ä¢ `!link` - Search for your player\n"
                                "‚Ä¢ `!link <name>` - Link by name\n"
                                "‚Ä¢ `!link <GUID>` - Link with GUID"
                            ),
                            inline=False,
                        )
                        embed.add_field(
                            name="Admin Help",
                            value=(
                                f"Admins can help link with:\n"
                                f"`!link {mentioned_user.mention} <GUID>`"
                            ),
                            inline=False,
                        )
                        await ctx.send(embed=embed)
                        return
                    
                    player_guid = link[0]
                    primary_name = link[1]
                    logger.info(
                        f"Stats via @mention: {ctx.author} looked up "
                        f"{mentioned_user} (GUID: {player_guid})"
                    )
                
                # === SCENARIO 2: NO ARGS - Use author's linked account ===
                elif not player_name:
                    discord_id = str(ctx.author.id)
                    async with db.execute(
                        '''
                        SELECT et_guid, et_name FROM player_links
                        WHERE discord_id = ?
                    ''',
                        (discord_id,),
                    ) as cursor:
                        link = await cursor.fetchone()
                    
                    if not link:
                        await ctx.send(
                            "‚ùå Please specify a player name or link your "
                            "account with `!link`"
                        )
                        return
                    
                    player_guid = link[0]
                    primary_name = link[1]

                # === SCENARIO 3: NAME SEARCH - Traditional lookup ===
                else:
                    # Try exact match in player_links first
                    async with db.execute(
                        '''
                        SELECT et_guid, et_name FROM player_links
                        WHERE LOWER(et_name) = LOWER(?)
                        LIMIT 1
                    ''',
                        (player_name,),
                    ) as cursor:
                        link = await cursor.fetchone()

                    if link:
                        player_guid = link[0]
                        primary_name = link[1]
                    else:
                        # Search in player_aliases
                        async with db.execute(
                            '''
                            SELECT player_guid, player_name
                            FROM player_aliases
                            WHERE LOWER(clean_name) LIKE LOWER(?)
                            ORDER BY last_seen DESC
                            LIMIT 1
                        ''',
                            (f'%{player_name}%',),
                        ) as cursor:
                            alias_result = await cursor.fetchone()
                        
                        if alias_result:
                            player_guid = alias_result[0]
                            primary_name = alias_result[1]
                        else:
                            # Fallback to player_comprehensive_stats
                            async with db.execute(
                                '''
                                SELECT player_guid, player_name
                                FROM player_comprehensive_stats
                                WHERE LOWER(player_name) LIKE LOWER(?)
                                GROUP BY player_guid
                                LIMIT 1
                            ''',
                                (f'%{player_name}%',),
                            ) as cursor:
                                result = await cursor.fetchone()
                                if not result:
                                    await ctx.send(
                                        f"‚ùå Player '{player_name}' not found."
                                    )
                                    return
                                player_guid = result[0]
                                primary_name = result[1]
                
                # === NOW WE HAVE player_guid AND primary_name - Get Stats ===

                # Get overall stats
                async with db.execute(
                    '''
                    SELECT
                        COUNT(DISTINCT session_id) as total_games,
                        SUM(kills) as total_kills,
                        SUM(deaths) as total_deaths,
                        SUM(damage_given) as total_damage,
                        SUM(damage_received) as total_damage_received,
                        SUM(headshot_kills) as total_headshots,
                        CASE
                            WHEN SUM(time_played_seconds) > 0
                            THEN (SUM(damage_given) * 60.0) / SUM(time_played_seconds)
                            ELSE 0
                        END as weighted_dpm,
                        AVG(kd_ratio) as avg_kd
                    FROM player_comprehensive_stats
                    WHERE player_guid = ?
                ''',
                    (player_guid,),
                ) as cursor:
                    overall = await cursor.fetchone()

                # Get weapon stats with accuracy
                async with db.execute(
                    '''
                    SELECT
                        SUM(w.hits) as total_hits,
                        SUM(w.shots) as total_shots,
                        SUM(w.headshots) as total_hs
                    FROM weapon_comprehensive_stats w
                    WHERE w.player_guid = ?
                ''',
                    (player_guid,),
                ) as cursor:
                    weapon_overall = await cursor.fetchone()

                # Get favorite weapons
                async with db.execute(
                    '''
                    SELECT weapon_name, SUM(kills) as total_kills
                    FROM weapon_comprehensive_stats
                    WHERE player_guid = ?
                    GROUP BY weapon_name
                    ORDER BY total_kills DESC
                    LIMIT 3
                ''',
                    (player_guid,),
                ) as cursor:
                    fav_weapons = await cursor.fetchall()

                # Get recent activity
                async with db.execute(
                    '''
                    SELECT s.session_date, s.map_name, p.kills, p.deaths
                    FROM player_comprehensive_stats p
                    JOIN sessions s ON p.session_id = s.id
                    WHERE p.player_guid = ?
                    ORDER BY s.session_date DESC
                    LIMIT 3
                ''',
                    (player_guid,),
                ) as cursor:
                    recent = await cursor.fetchall()

                # Calculate stats
                games, kills, deaths, dmg, dmg_recv, hs, avg_dpm, avg_kd = overall
                hits, shots, hs_weapon = weapon_overall if weapon_overall else (0, 0, 0)

                kd_ratio = kills / deaths if deaths > 0 else kills
                accuracy = (hits / shots * 100) if shots > 0 else 0
                hs_pct = (hs / hits * 100) if hits > 0 else 0

                # Build embed
                embed = discord.Embed(
                    title=f"üìä Stats for {primary_name}",
                    color=0x0099FF,
                    timestamp=datetime.now(),
                )

                embed.add_field(
                    name="üéÆ Overview",
                    value=(
                        f"**Games Played:** {games:,}\\n**K/D Ratio:** {kd_ratio:.2f}\\n**Avg DPM:** {avg_dpm:.1f}"
                        if avg_dpm
                        else "0.0"
                    ),
                    inline=True,
                )

                embed.add_field(
                    name="‚öîÔ∏è Combat",
                    value=f"**Kills:** {kills:,}\\n**Deaths:** {deaths:,}\\n**Headshots:** {hs:,} ({hs_pct:.1f}%)",
                    inline=True,
                )

                embed.add_field(
                    name="üéØ Accuracy",
                    value=f"**Overall:** {accuracy:.1f}%\\n**Damage Given:** {dmg:,}\\n**Damage Taken:** {dmg_recv:,}",
                    inline=True,
                )

                if fav_weapons:
                    weapons_text = "\\n".join(
                        [f"**{w[0].replace('WS_', '').title()}:** {w[1]:,} kills" for w in fav_weapons]
                    )
                    embed.add_field(name="üî´ Favorite Weapons", value=weapons_text, inline=False)

                if recent:
                    recent_text = "\\n".join([f"`{r[0]}` **{r[1]}** - {r[2]}K/{r[3]}D" for r in recent])
                    embed.add_field(name="üìÖ Recent Matches", value=recent_text, inline=False)

                # Get aliases for footer
                async with db.execute(
                    '''
                    SELECT player_name
                    FROM player_aliases
                    WHERE player_guid = ? AND LOWER(player_name) != LOWER(?)
                    ORDER BY last_seen DESC, times_used DESC
                    LIMIT 3
                ''',
                    (player_guid, primary_name),
                ) as cursor:
                    aliases = await cursor.fetchall()

                # Build footer with GUID and aliases
                footer_text = f"GUID: {player_guid}"
                if aliases:
                    alias_names = ", ".join([a[0] for a in aliases])
                    footer_text += f" | Also known as: {alias_names}"
                
                embed.set_footer(text=footer_text)
                await ctx.send(embed=embed)

        except Exception as e:
            logger.error(f"Error in stats command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error retrieving stats: {e}")

    @commands.command(name='leaderboard', aliases=['lb', 'top'])
    async def leaderboard(self, ctx, stat_type: str = 'kills', page: int = 1):
        """üèÜ Show players leaderboard with pagination

        Usage:
        - !lb              ‚Üí First page (kills)
        - !lb 2            ‚Üí Page 2 (kills)
        - !lb dpm          ‚Üí First page (DPM)
        - !lb dpm 2        ‚Üí Page 2 (DPM)

        Available stat types:
        - kills: Total kills
        - kd: Kill/Death ratio
        - dpm: Damage per minute
        - accuracy/acc: Overall accuracy
        - headshots/hs: Headshot percentage
        - games: Games played
        - revives: Most revives given (medic)
        - gibs: Most gibs (finishing moves)
        - objectives/obj: Most objectives completed
        - efficiency/eff: Highest efficiency rating
        - teamwork: Best teamwork (lowest team damage %)
        - multikills: Most multikills (doubles, triples, etc)
        - grenades/nades: Top grenadiers (grenade kills + accuracy)
        """
        try:
            # Handle case where user passes page number as first arg
            # e.g., !lb 2 should be interpreted as page 2 of kills
            if stat_type.isdigit():
                page = int(stat_type)
                stat_type = 'kills'
            else:
                stat_type = stat_type.lower()
            
            # Ensure page is at least 1
            page = max(1, page)
            
            # 10 players per page
            players_per_page = 10
            offset = (page - 1) * players_per_page

            # Map aliases to stat types
            stat_aliases = {
                'k': 'kills',
                'kill': 'kills',
                'kd': 'kd',
                'ratio': 'kd',
                'dpm': 'dpm',
                'damage': 'dpm',
                'acc': 'accuracy',
                'accuracy': 'accuracy',
                'hs': 'headshots',
                'headshot': 'headshots',
                'headshots': 'headshots',
                'games': 'games',
                'played': 'games',
                'revives': 'revives',
                'revive': 'revives',
                'medic': 'revives',
                'gibs': 'gibs',
                'gib': 'gibs',
                'obj': 'objectives',
                'objective': 'objectives',
                'objectives': 'objectives',
                'eff': 'efficiency',
                'efficiency': 'efficiency',
                'teamwork': 'teamwork',
                'team': 'teamwork',
                'multikill': 'multikills',
                'multikills': 'multikills',
                'multi': 'multikills',
                'grenade': 'grenades',
                'grenades': 'grenades',
                'nades': 'grenades',
                'nade': 'grenades',
            }

            stat_type = stat_aliases.get(stat_type, 'kills')

            async with aiosqlite.connect(self.bot.db_path) as db:
                # Get total count for pagination
                count_query = '''
                    SELECT COUNT(DISTINCT player_guid) 
                    FROM player_comprehensive_stats
                '''
                async with db.execute(count_query) as cursor:
                    total_players = (await cursor.fetchone())[0]
                
                total_pages = (total_players + players_per_page - 1) // players_per_page
                
                if stat_type == 'kills':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.kills) as total_kills,
                            SUM(p.deaths) as total_deaths,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 10
                        ORDER BY total_kills DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Top Players by Kills (Page {page}/{total_pages})"

                elif stat_type == 'kd':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.kills) as total_kills,
                            SUM(p.deaths) as total_deaths,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 50 AND total_deaths > 0
                        ORDER BY (CAST(total_kills AS FLOAT) / total_deaths) DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Top Players by K/D Ratio (Page {page}/{total_pages})"

                elif stat_type == 'dpm':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            CASE
                                WHEN SUM(p.time_played_seconds) > 0
                                THEN (SUM(p.damage_given) * 60.0) / SUM(p.time_played_seconds)
                                ELSE 0
                            END as weighted_dpm,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 50
                        ORDER BY weighted_dpm DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Top Players by DPM (Page {page}/{total_pages})"

                elif stat_type == 'accuracy':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(w.hits) as total_hits,
                            SUM(w.shots) as total_shots,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        JOIN weapon_comprehensive_stats w
                            ON p.session_id = w.session_id
                            AND p.player_guid = w.player_guid
                        GROUP BY p.player_guid
                        HAVING games > 50 AND total_shots > 1000
                        ORDER BY (CAST(total_hits AS FLOAT) / total_shots) DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Top Players by Accuracy (Page {page}/{total_pages})"

                elif stat_type == 'headshots':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.headshot_kills) as total_hs,
                            SUM(w.hits) as total_hits,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        JOIN weapon_comprehensive_stats w
                            ON p.session_id = w.session_id
                            AND p.player_guid = w.player_guid
                        GROUP BY p.player_guid
                        HAVING games > 50 AND total_hits > 1000
                        ORDER BY (CAST(total_hs AS FLOAT) / total_hits) DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Top Players by Headshot % (Page {page}/{total_pages})"

                elif stat_type == 'games':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            COUNT(DISTINCT p.session_id) as games,
                            SUM(p.kills) as total_kills,
                            SUM(p.deaths) as total_deaths,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        ORDER BY games DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üèÜ Most Active Players (Page {page}/{total_pages})"

                elif stat_type == 'revives':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.times_revived) as total_revives,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 10
                        ORDER BY total_revives DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üíâ Top Medics - Teammates Revived (Page {page}/{total_pages})"

                elif stat_type == 'gibs':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.gibs) as total_gibs,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 10
                        ORDER BY total_gibs DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üíÄ Top Gibbers (Page {page}/{total_pages})"

                elif stat_type == 'objectives':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.objectives_completed + p.objectives_destroyed + p.objectives_stolen + p.objectives_returned) as total_obj,
                            SUM(p.objectives_completed) as completed,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 10
                        ORDER BY total_obj DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üéØ Top Objective Players (Page {page}/{total_pages})"

                elif stat_type == 'efficiency':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            AVG(p.efficiency) as avg_eff,
                            SUM(p.kills) as total_kills,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 50
                        ORDER BY avg_eff DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"‚ö° Highest Efficiency (Page {page}/{total_pages})"

                elif stat_type == 'teamwork':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.team_damage_given) as total_team_dmg,
                            SUM(p.damage_given) as total_dmg,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 50 AND total_dmg > 0
                        ORDER BY (CAST(total_team_dmg AS FLOAT) / total_dmg) ASC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"ü§ù Best Teamwork (Lowest Team Damage %) (Page {page}/{total_pages})"

                elif stat_type == 'multikills':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = p.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(p.double_kills + p.triple_kills + p.quad_kills + p.multi_kills + p.mega_kills) as total_multi,
                            SUM(p.mega_kills) as megas,
                            COUNT(DISTINCT p.session_id) as games,
                            p.player_guid
                        FROM player_comprehensive_stats p
                        GROUP BY p.player_guid
                        HAVING games > 10
                        ORDER BY total_multi DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üî• Most Multikills (Page {page}/{total_pages})"

                elif stat_type == 'grenades':
                    query = f'''
                        SELECT 
                            (SELECT player_name FROM player_comprehensive_stats 
                             WHERE player_guid = w.player_guid 
                             GROUP BY player_name 
                             ORDER BY COUNT(*) DESC LIMIT 1) as primary_name,
                            SUM(w.kills) as total_kills,
                            SUM(w.shots) as total_throws,
                            SUM(w.hits) as total_hits,
                            CASE 
                                WHEN SUM(w.kills) > 0 
                                THEN ROUND(CAST(SUM(w.hits) AS FLOAT) / SUM(w.kills), 2)
                                ELSE 0 
                            END as aoe_ratio,
                            COUNT(DISTINCT w.session_id) as games,
                            w.player_guid
                        FROM weapon_comprehensive_stats w
                        WHERE w.weapon_name = 'WS_GRENADE'
                        GROUP BY w.player_guid
                        HAVING games > 10
                        ORDER BY total_kills DESC
                        LIMIT {players_per_page} OFFSET {offset}
                    '''
                    title = f"üí£ Top Grenadiers - AOE Masters (Page {page}/{total_pages})"

                async with db.execute(query) as cursor:
                    results = await cursor.fetchall()

            if not results:
                await ctx.send(f"‚ùå No data found for leaderboard type: {stat_type}")
                return

            # Build embed
            embed = discord.Embed(
                title=title, color=0xFFD700, timestamp=datetime.now()  # Gold color
            )

            # Format results based on stat type
            leaderboard_text = ""
            medals = ["ü•á", "ü•à", "ü•â"]

            for i, row in enumerate(results):
                # Calculate actual rank (based on page)
                rank = offset + i + 1
                
                # Use medal for top 3 overall, otherwise show rank number
                if rank <= 3:
                    medal = medals[rank - 1]
                else:
                    medal = f"{rank}."
                
                name = row[0]
                
                # Add dev badge for ciril (bot developer)
                player_guid = row[-1]  # GUID is always last column
                if player_guid == 'E587CA5F':
                    name = f"{name} üëë"  # Crown emoji for dev

                if stat_type == 'kills':
                    kills, deaths, games = row[1], row[2], row[3]
                    kd = kills / deaths if deaths > 0 else kills
                    leaderboard_text += f"{medal} **{name}** - {kills:,}K ({kd:.2f} K/D, {games} games)\n"

                elif stat_type == 'kd':
                    kills, deaths, games = row[1], row[2], row[3]
                    kd = kills / deaths if deaths > 0 else kills
                    leaderboard_text += f"{medal} **{name}** - {kd:.2f} K/D ({kills:,}K/{deaths:,}D, {games} games)\n"

                elif stat_type == 'dpm':
                    avg_dpm, kills, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {avg_dpm:.1f} DPM ({kills:,}K, {games} games)\n"

                elif stat_type == 'accuracy':
                    hits, shots, kills, games = row[1], row[2], row[3], row[4]
                    acc = (hits / shots * 100) if shots > 0 else 0
                    leaderboard_text += f"{medal} **{name}** - {acc:.1f}% Acc ({kills:,}K, {games} games)\n"

                elif stat_type == 'headshots':
                    hs, hits, kills, games = row[1], row[2], row[3], row[4]
                    hs_pct = (hs / hits * 100) if hits > 0 else 0
                    leaderboard_text += f"{medal} **{name}** - {hs_pct:.1f}% HS ({hs:,} HS, {games} games)\n"

                elif stat_type == 'games':
                    games, kills, deaths = row[1], row[2], row[3]
                    kd = kills / deaths if deaths > 0 else kills
                    leaderboard_text += f"{medal} **{name}** - {games:,} games ({kills:,}K, {kd:.2f} K/D)\n"

                elif stat_type == 'revives':
                    revives, kills, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {revives:,} teammates revived ({kills:,}K, {games} games)\n"

                elif stat_type == 'gibs':
                    gibs, kills, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {gibs:,} gibs ({kills:,}K, {games} games)\n"

                elif stat_type == 'objectives':
                    total_obj, completed, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {total_obj:,} objectives ({completed} completed, {games} games)\n"

                elif stat_type == 'efficiency':
                    avg_eff, kills, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {avg_eff:.1f} efficiency ({kills:,}K, {games} games)\n"

                elif stat_type == 'teamwork':
                    team_dmg, total_dmg, games = row[1], row[2], row[3]
                    team_pct = (team_dmg / total_dmg * 100) if total_dmg > 0 else 0
                    leaderboard_text += f"{medal} **{name}** - {team_pct:.2f}% team damage ({games} games)\n"

                elif stat_type == 'multikills':
                    total_multi, megas, games = row[1], row[2], row[3]
                    leaderboard_text += f"{medal} **{name}** - {total_multi:,} multikills ({megas} mega, {games} games)\n"

                elif stat_type == 'grenades':
                    kills, throws, hits, aoe_ratio, games = row[1], row[2], row[3], row[4], row[5]
                    accuracy = (hits / throws * 100) if throws > 0 else 0
                    aoe_emoji = "üî•" if aoe_ratio >= 3.0 else ""
                    leaderboard_text += f"{medal} **{name}** - {kills:,} kills ‚Ä¢ {accuracy:.1f}% acc ‚Ä¢ {aoe_ratio:.2f} AOE {aoe_emoji} ({games} games)\n"

            embed.description = leaderboard_text

            # Add usage footer with pagination info
            if page < total_pages:
                next_page_hint = f" | Next: !lb {stat_type} {page + 1}"
            else:
                next_page_hint = ""
            
            footer_text = f"üí° Use !lb [stat] [page]{next_page_hint}"
            embed.set_footer(text=footer_text)

            await ctx.send(embed=embed)

        except Exception as e:
            logger.error(f"Error in leaderboard command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error retrieving leaderboard: {e}")

    @commands.command(name='session', aliases=['match', 'game'])
    async def session(self, ctx, date_filter: str = None):
        """üìÖ Show detailed session/match statistics

        Usage:
        - !session 2025-09-30  (show sessions from specific date)
        - !session  (show most recent sessions)
        """
        try:
            if not date_filter:
                # Get most recent date
                async with aiosqlite.connect(self.bot.db_path) as db:
                    async with db.execute(
                        '''
                        SELECT session_date FROM sessions
                        ORDER BY session_date DESC LIMIT 1
                    '''
                    ) as cursor:
                        result = await cursor.fetchone()
                        if not result:
                            await ctx.send("‚ùå No sessions found in database")
                            return
                        date_filter = result[0][:10]  # Get YYYY-MM-DD part

            async with aiosqlite.connect(self.bot.db_path) as db:
                # Get sessions for the date
                async with db.execute(
                    '''
                    SELECT id, session_date, map_name, round_number,
                           time_limit, actual_time
                    FROM sessions
                    WHERE session_date LIKE ?
                    ORDER BY session_date DESC
                    LIMIT 5
                ''',
                    (f'{date_filter}%',),
                ) as cursor:
                    sessions = await cursor.fetchall()

                if not sessions:
                    await ctx.send(f"‚ùå No sessions found for date: {date_filter}")
                    return

                # Show first session in detail (limit message size)
                session = sessions[0]
                session_id, date, map_name, round_num, time_limit, actual_time = session

                # Get player count
                async with db.execute(
                    '''
                    SELECT COUNT(*) FROM player_comprehensive_stats
                    WHERE session_id = ?
                ''',
                    (session_id,),
                ) as cursor:
                    player_count = (await cursor.fetchone())[0]

                # Get top 5 players
                async with db.execute(
                    '''
                    SELECT p.player_name, p.kills, p.deaths, p.dpm,
                           SUM(w.hits) as total_hits, SUM(w.shots) as total_shots,
                           p.headshot_kills
                    FROM player_comprehensive_stats p
                    LEFT JOIN weapon_comprehensive_stats w
                        ON p.session_id = w.session_id
                        AND p.player_guid = w.player_guid
                    WHERE p.session_id = ?
                    GROUP BY p.player_name, p.kills, p.deaths, p.dpm, p.headshot_kills
                    ORDER BY p.kills DESC
                    LIMIT 5
                ''',
                    (session_id,),
                ) as cursor:
                    top_players = await cursor.fetchall()

                # Get team stats
                async with db.execute(
                    '''
                    SELECT team, SUM(kills) as total_kills, SUM(deaths) as total_deaths,
                           SUM(damage_given) as total_damage
                    FROM player_comprehensive_stats
                    WHERE session_id = ?
                    GROUP BY team
                ''',
                    (session_id,),
                ) as cursor:
                    team_stats = await cursor.fetchall()

            # Build embed
            embed = discord.Embed(
                title=f"üìç Session #{session_id}: {map_name}",
                description=f"**Round {round_num}** ‚Ä¢ {actual_time} duration ‚Ä¢ {player_count} players",
                color=0x00FF88,
                timestamp=datetime.now(),
            )

            # Top performers
            if top_players:
                top_text = ""
                medals = ["ü•á", "ü•à", "ü•â", "4.", "5."]
                for i, (name, kills, deaths, dpm, hits, shots, hs) in enumerate(top_players):
                    kd_str = f"{kills}/{deaths}"
                    acc = (hits / shots * 100) if shots and shots > 0 else 0
                    hs_pct = (hs / hits * 100) if hits and hits > 0 else 0
                    dpm_str = f"{dpm:.0f}" if dpm else "0"
                    top_text += f"{
                        medals[i]} **{name}** - {kd_str} K/D ({dpm_str} DPM, {
                        acc:.1f}% acc, {
                        hs_pct:.1f}% HS)\\n"

                embed.add_field(name="üèÜ Top 5 Players", value=top_text, inline=False)

            # Team stats
            if len(team_stats) > 1:
                team_text = ""
                for team, kills, deaths, damage in team_stats:
                    if team == 1:
                        team_name = "Axis"
                        emoji = "üî¥"
                    elif team == 2:
                        team_name = "Allies"
                        emoji = "üîµ"
                    else:
                        team_name = f"Team {team}"
                        emoji = "‚ö™"
                    team_text += f"{emoji} **{team_name}**: {kills}K / {deaths}D ({
                        damage:,} dmg)\\n"

                embed.add_field(name="‚öîÔ∏è Team Statistics", value=team_text, inline=False)

            # Show count of other sessions
            if len(sessions) > 1:
                other_sessions = "\\n".join(
                    [f"‚Ä¢ Session #{s[0]}: {s[2]} (Round {s[3]})" for s in sessions[1:]]
                )
                embed.add_field(
                    name=f"üìã Other Sessions on {date_filter}", value=other_sessions, inline=False
                )

            embed.set_footer(text=f"Date: {date}")
            await ctx.send(embed=embed)

        except Exception as e:
            logger.error(f"Error in session command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error retrieving session: {e}")

    @commands.command(name='last_session', aliases=['last', 'latest', 'recent'])
    async def last_session(self, ctx):
        """üéÆ Show the most recent session/match

        Displays detailed stats for the latest played session (full day).
        A session = one day of gaming with all maps/rounds.
        """
        try:
            async with aiosqlite.connect(self.bot.db_path) as db:
                # Get the most recent date (using SUBSTR to handle both "2025-10-02" and "2025-10-02-221711" formats)
                async with db.execute(
                    '''
                    SELECT DISTINCT SUBSTR(session_date, 1, 10) as date
                    FROM sessions
                    ORDER BY date DESC
                    LIMIT 1
                '''
                ) as cursor:
                    result = await cursor.fetchone()

                if not result:
                    await ctx.send("‚ùå No sessions found in database")
                    return

                latest_date = result[0]

                # Get all session IDs for this date (chronologically)
                async with db.execute(
                    '''
                    SELECT id, map_name, round_number, actual_time
                    FROM sessions
                    WHERE SUBSTR(session_date, 1, 10) = ?
                    ORDER BY id ASC
                ''',
                    (latest_date,),
                ) as cursor:
                    sessions = await cursor.fetchall()

                if not sessions:
                    await ctx.send("‚ùå No sessions found for latest date")
                    return

                session_ids = [s[0] for s in sessions]
                session_ids_str = ','.join('?' * len(session_ids))

                # Get unique player count across all sessions
                query = f'''
                    SELECT COUNT(DISTINCT player_guid)
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                '''
                async with db.execute(query, session_ids) as cursor:
                    player_count = (await cursor.fetchone())[0]

                # Get ALL players (aggregated across all rounds)
                # Calculate WEIGHTED DPM using actual playtime per round
                query = f'''
                    SELECT p.player_name,
                           SUM(p.kills) as kills,
                           SUM(p.deaths) as deaths,
                           CASE
                               WHEN SUM(p.time_played_seconds) > 0
                               THEN (SUM(p.damage_given) * 60.0) / SUM(p.time_played_seconds)
                               ELSE 0
                           END as weighted_dpm,
                           COALESCE(SUM(w.hits), 0) as total_hits,
                           COALESCE(SUM(w.shots), 0) as total_shots,
                           COALESCE(SUM(w.headshots), 0) as total_headshots,
                           SUM(p.headshot_kills) as headshot_kills,
                           SUM(p.time_played_seconds) as total_seconds,
                           CAST(SUM(p.time_played_seconds * p.time_dead_ratio / 100.0) AS INTEGER) as total_time_dead
                    FROM player_comprehensive_stats p
                    LEFT JOIN (
                        SELECT session_id, player_guid,
                               SUM(hits) as hits,
                               SUM(shots) as shots,
                               SUM(headshots) as headshots
                        FROM weapon_comprehensive_stats
                        WHERE weapon_name NOT IN ('WS_GRENADE', 'WS_SYRINGE', 'WS_DYNAMITE', 'WS_AIRSTRIKE', 'WS_ARTILLERY', 'WS_SATCHEL', 'WS_LANDMINE')
                        GROUP BY session_id, player_guid
                    ) w ON p.session_id = w.session_id AND p.player_guid = w.player_guid
                    WHERE p.session_id IN ({session_ids_str})
                    GROUP BY p.player_name
                    ORDER BY kills DESC
                '''
                async with db.execute(query, session_ids) as cursor:
                    all_players = await cursor.fetchall()

                # Get team stats (aggregated)
                query = f'''
                    SELECT team,
                           SUM(kills) as total_kills,
                           SUM(deaths) as total_deaths,
                           SUM(damage_given) as total_damage
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY team
                '''
                async with db.execute(query, session_ids) as cursor:
                    team_stats = await cursor.fetchall()

                # Get detailed weapon stats (individual weapons)
                query = f'''
                    SELECT weapon_name,
                           SUM(kills) as total_kills,
                           SUM(deaths) as total_deaths,
                           SUM(hits) as total_hits,
                           SUM(shots) as total_shots,
                           SUM(headshots) as total_headshots
                    FROM weapon_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY weapon_name
                    HAVING total_kills > 0
                    ORDER BY total_kills DESC
                '''
                async with db.execute(query, session_ids) as cursor:
                    await cursor.fetchall()

                # Get per-player weapon mastery
                query = f'''
                    SELECT p.player_name,
                           w.weapon_name,
                           SUM(w.kills) as weapon_kills,
                           SUM(w.hits) as weapon_hits,
                           SUM(w.shots) as weapon_shots,
                           SUM(w.headshots) as weapon_headshots
                    FROM weapon_comprehensive_stats w
                    JOIN player_comprehensive_stats p
                        ON w.session_id = p.session_id
                        AND w.player_guid = p.player_guid
                    WHERE w.session_id IN ({session_ids_str})
                    GROUP BY p.player_name, w.weapon_name
                    HAVING weapon_kills > 0
                    ORDER BY p.player_name, weapon_kills DESC
                '''
                async with db.execute(query, session_ids) as cursor:
                    player_weapons = await cursor.fetchall()

                # Get DPM leaderboard (weighted by actual playtime)
                query = f'''
                    SELECT player_name,
                           CASE
                               WHEN SUM(time_played_seconds) > 0
                               THEN (SUM(damage_given) * 60.0) / SUM(time_played_seconds)
                               ELSE 0
                           END as weighted_dpm,
                           SUM(kills) as total_kills,
                           SUM(deaths) as total_deaths
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY player_name
                    ORDER BY weighted_dpm DESC
                    LIMIT 10
                '''
                async with db.execute(query, session_ids) as cursor:
                    dpm_leaders = await cursor.fetchall()

                # üéØ TRY TO GET HARDCODED TEAMS FIRST
                hardcoded_teams = await self.get_hardcoded_teams(db, latest_date)
                
                if hardcoded_teams:
                    # ‚úÖ We have hardcoded teams! Use them for accurate team tracking
                    logger.info("‚úÖ Using hardcoded teams from session_teams table")
                    
                    # Extract team names and create GUID-to-team mapping
                    team_names_list = list(hardcoded_teams.keys())
                    team_1_name = team_names_list[0] if len(team_names_list) > 0 else 'Team A'
                    team_2_name = team_names_list[1] if len(team_names_list) > 1 else 'Team B'
                    
                    # Create GUID -> team_name mapping
                    guid_to_team = {}
                    for team_name, team_data in hardcoded_teams.items():
                        for guid in team_data['guids']:
                            guid_to_team[guid] = team_name
                    
                    # Get player GUIDs to map names to teams
                    query = f'''
                        SELECT DISTINCT player_name, player_guid
                        FROM player_comprehensive_stats
                        WHERE session_id IN ({session_ids_str})
                    '''
                    async with db.execute(query, session_ids) as cursor:
                        player_guid_map = await cursor.fetchall()
                    
                    # Build name -> team mapping
                    name_to_team = {}
                    for player_name, player_guid in player_guid_map:
                        if player_guid in guid_to_team:
                            name_to_team[player_name] = guid_to_team[player_guid]
                    
                    # Organize players by hardcoded team
                    team_1_players_list = [name for name, team in name_to_team.items() if team == team_1_name]
                    team_2_players_list = [name for name, team in name_to_team.items() if team == team_2_name]
                    
                    # No team swappers when using hardcoded teams (they stay consistent)
                    team_swappers = {}
                    player_teams = {name: [(team, 1)] for name, team in name_to_team.items()}
                    
                else:
                    # ‚ùå No hardcoded teams - fall back to old Axis/Allies detection
                    logger.info("‚ö†Ô∏è  No hardcoded teams found, using Axis/Allies (may be inaccurate)")
                    
                    # Get team composition - who played for which team
                    query = f'''
                        SELECT player_name, team, COUNT(*) as rounds_played
                        FROM player_comprehensive_stats
                        WHERE session_id IN ({session_ids_str})
                        GROUP BY player_name, team
                        ORDER BY player_name, rounds_played DESC
                    '''
                    async with db.execute(query, session_ids) as cursor:
                        team_composition = await cursor.fetchall()

                    # Assign random team names
                    import random

                    team_name_pool = ['puran', 'insAne', 'sWat', 'maDdogs', 'slomix', 'slo']

                    # Get all unique players and their primary team
                    player_primary_teams = {}
                    for player, team, rounds in team_composition:
                        if player not in player_primary_teams:
                            player_primary_teams[player] = team

                    # Separate players by team
                    team_1_players_list = [p for p, t in player_primary_teams.items() if t == 1]
                    team_2_players_list = [p for p, t in player_primary_teams.items() if t == 2]

                    # Randomly assign team names
                    random.shuffle(team_name_pool)
                    team_1_name = team_name_pool[0] if team_name_pool else 'Team 1'
                    team_2_name = team_name_pool[1] if len(team_name_pool) > 1 else 'Team 2'

                    # Detect team swaps - players who played for multiple teams
                    player_teams = {}
                    for player, team, rounds in team_composition:
                        if player not in player_teams:
                            player_teams[player] = []
                        player_teams[player].append((team, rounds))

                    team_swappers = {
                        player: teams for player, teams in player_teams.items() if len(teams) > 1
                    }

                # üéØ GET MVP PER TEAM (using hardcoded teams if available)
                team_mvps = {}
                
                if hardcoded_teams:
                    # ‚úÖ Calculate MVP per hardcoded team (by GUID)
                    for team_name, team_data in hardcoded_teams.items():
                        team_guids = team_data['guids']
                        team_guids_placeholders = ','.join('?' * len(team_guids))
                        
                        query = f'''
                            SELECT player_name, SUM(kills) as total_kills, player_guid
                            FROM player_comprehensive_stats
                            WHERE session_id IN ({session_ids_str})
                            AND player_guid IN ({team_guids_placeholders})
                            GROUP BY player_name, player_guid
                            ORDER BY total_kills DESC
                            LIMIT 1
                        '''
                        params = session_ids + team_guids
                        async with db.execute(query, params) as cursor:
                            result = await cursor.fetchone()
                            if result:
                                player_name, kills, guid = result
                                team_mvps[team_name] = (player_name, kills)
                else:
                    # ‚ùå Fall back to old Axis/Allies MVP calculation
                    query = f'''
                        SELECT team, player_name, SUM(kills) as total_kills
                        FROM player_comprehensive_stats
                        WHERE session_id IN ({session_ids_str})
                        GROUP BY team, player_name
                        ORDER BY team, total_kills DESC
                    '''
                    async with db.execute(query, session_ids) as cursor:
                        team_mvps_raw = await cursor.fetchall()

                    # Get top player per team
                    for team, player, kills in team_mvps_raw:
                        if team not in team_mvps:
                            team_mvps[team] = (player, kills)

                # üéØ GET DETAILED MVP STATS (using hardcoded teams if available)
                team_1_mvp_stats = None
                team_2_mvp_stats = None

                if hardcoded_teams:
                    # ‚úÖ Get MVP stats for hardcoded teams
                    for team_name in [team_1_name, team_2_name]:
                        if team_name in team_mvps:
                            player, kills = team_mvps[team_name]
                            team_guids = hardcoded_teams[team_name]['guids']
                            team_guids_placeholders = ','.join('?' * len(team_guids))
                            
                            query = f'''
                                SELECT
                                    CASE
                                        WHEN SUM(time_played_seconds) > 0
                                        THEN (SUM(damage_given) * 60.0) / SUM(time_played_seconds)
                                        ELSE 0
                                    END as weighted_dpm,
                                    SUM(deaths),
                                    SUM(times_revived),
                                    SUM(gibs)
                                FROM player_comprehensive_stats
                                WHERE session_id IN ({session_ids_str})
                                AND player_name = ?
                                AND player_guid IN ({team_guids_placeholders})
                            '''
                            params = session_ids + [player] + team_guids
                            async with db.execute(query, params) as cursor:
                                result = await cursor.fetchone()
                                if result:
                                    mvp_stats = (player, kills, result[0], result[1], result[2], result[3])
                                    if team_name == team_1_name:
                                        team_1_mvp_stats = mvp_stats
                                    else:
                                        team_2_mvp_stats = mvp_stats
                else:
                    # ‚ùå Fall back to old Axis/Allies MVP stats
                    if 1 in team_mvps:
                        player, kills = team_mvps[1]
                        query = f'''
                            SELECT
                                CASE
                                    WHEN SUM(time_played_seconds) > 0
                                    THEN (SUM(damage_given) * 60.0) / SUM(time_played_seconds)
                                    ELSE 0
                                END as weighted_dpm,
                                SUM(deaths),
                                SUM(times_revived),
                                SUM(gibs)
                            FROM player_comprehensive_stats
                            WHERE session_id IN ({session_ids_str})
                            AND player_name = ? AND team = 1
                        '''
                        async with db.execute(query, session_ids + [player]) as cursor:
                            result = await cursor.fetchone()
                            if result:
                                team_1_mvp_stats = (
                                    player,
                                    kills,
                                    result[0],
                                    result[1],
                                    result[2],
                                    result[3],
                                )

                    if 2 in team_mvps:
                        player, kills = team_mvps[2]
                        query = f'''
                            SELECT
                                CASE
                                    WHEN SUM(time_played_seconds) > 0
                                    THEN (SUM(damage_given) * 60.0) / SUM(time_played_seconds)
                                    ELSE 0
                                END as weighted_dpm,
                                SUM(deaths),
                                SUM(times_revived),
                                SUM(gibs)
                            FROM player_comprehensive_stats
                            WHERE session_id IN ({session_ids_str})
                            AND player_name = ? AND team = 2
                        '''
                        async with db.execute(query, session_ids + [player]) as cursor:
                            result = await cursor.fetchone()
                            if result:
                                team_2_mvp_stats = (
                                    player,
                                    kills,
                                    result[0],
                                    result[1],
                                    result[2],
                                    result[3],
                                )

                # Count rounds won by each team (winners determined by session data)
                # For now, we'll count based on team performance
                # This is a simplified version - you might want to track actual round winners
                axis_rounds = sum(1 for s in sessions if s[2] % 2 == 1)  # Odd rounds
                allies_rounds = sum(1 for s in sessions if s[2] % 2 == 0)  # Even rounds

                # Fetch awards/objective stats data (MUST BE BEFORE CONNECTION CLOSES)
                query = f'''
                    SELECT clean_name, xp, kill_assists, objectives_stolen, objectives_returned,
                           dynamites_planted, dynamites_defused, times_revived,
                           double_kills, triple_kills, quad_kills, multi_kills, mega_kills,
                           denied_playtime, most_useful_kills, useless_kills, gibs,
                           killing_spree_best, death_spree_worst
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                '''
                async with db.execute(query, session_ids) as cursor:
                    awards_data = await cursor.fetchall()

                # Fetch player revives for weapon mastery embed
                query = f'''
                    SELECT player_name, SUM(times_revived) as revives
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY player_name
                '''
                async with db.execute(query, session_ids) as cursor:
                    player_revives_raw = await cursor.fetchall()

                # Fetch per-map breakdown data for Graph 3
                query = f'''
                    SELECT
                        s.map_name,
                        p.clean_name,
                        SUM(p.kills) as kills,
                        SUM(p.deaths) as deaths,
                        AVG(p.dpm) as avg_dpm
                    FROM player_comprehensive_stats p
                    JOIN sessions s ON p.session_id = s.id
                    WHERE p.session_id IN ({session_ids_str})
                    GROUP BY s.map_name, p.clean_name
                    ORDER BY s.map_name, kills DESC
                '''
                async with db.execute(query, session_ids) as cursor:
                    per_map_data = await cursor.fetchall()

                # Fetch additional stats for Graph 2 (Revives, Gibs, Useful Kills)
                query = f'''
                    SELECT
                        clean_name,
                        SUM(revives_given) as total_revives,
                        SUM(gibs) as total_gibs,
                        SUM(most_useful_kills) as total_useful_kills,
                        SUM(damage_given) as total_damage
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY clean_name
                    ORDER BY total_damage DESC
                    LIMIT 6
                '''
                async with db.execute(query, session_ids) as cursor:
                    advanced_graph_data = await cursor.fetchall()

                # Fetch chaos/awards stats (teamkills, self-kills, efficiency, etc)
                query = f'''
                    SELECT
                        clean_name,
                        SUM(team_kills) as total_teamkills,
                        SUM(self_kills) as total_selfkills,
                        SUM(kill_steals) as total_steals,
                        SUM(bullets_fired) as total_bullets,
                        SUM(kills) as total_kills,
                        SUM(deaths) as total_deaths,
                        SUM(damage_given) as total_dmg_given,
                        SUM(damage_received) as total_dmg_received,
                        SUM(constructions) as total_constructions,
                        SUM(tank_meatshield) as total_tank,
                        SUM(useless_kills) as total_useless_kills,
                        MAX(death_spree_worst) as worst_death_spree,
                        SUM(time_played_seconds) as total_time
                    FROM player_comprehensive_stats
                    WHERE session_id IN ({session_ids_str})
                    GROUP BY clean_name
                '''
                async with db.execute(query, session_ids) as cursor:
                    chaos_awards_data = await cursor.fetchall()

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # All database queries complete - connection closed
            # Now build and send embeds
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 1: Session Overview
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            maps_played = len(set(s[1] for s in sessions))
            rounds_played = len(sessions)

            embed1 = discord.Embed(
                title=f"üìä Session Summary: {latest_date}",
                description=(
                    f"**{maps_played} maps** ‚Ä¢ **{rounds_played} rounds** ‚Ä¢ "
                    f"**{player_count} players**"
                ),
                color=0x5865F2,
                timestamp=datetime.now(),
            )

            # Maps list - count ALL round 2 completions for each map
            maps_text = ""
            map_play_counts = {}
            for session_id, map_name, round_num, actual_time in sessions:
                # Count EVERY time we see round 2 (completes a 2-round map play)
                if round_num == 2:
                    map_play_counts[map_name] = map_play_counts.get(map_name, 0) + 1

            for map_name, plays in map_play_counts.items():
                rounds = plays * 2
                maps_text += f"‚Ä¢ **{map_name}** ({rounds} rounds)\n"

            if maps_text:
                embed1.add_field(name="üó∫Ô∏è Maps Played", value=maps_text, inline=False)

            # All players on embed1
            if all_players:
                top_text = ""
                medals = ["ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"]
                for i, player in enumerate(all_players):
                    name, kills, deaths, dpm, hits, shots = player[0:6]
                    total_hs, hsk, total_seconds, total_time_dead = player[6:10]

                    # Handle NULL values from database
                    kills = kills or 0
                    deaths = deaths or 0
                    dpm = dpm or 0
                    hits = hits or 0
                    shots = shots or 0
                    total_hs = total_hs or 0
                    hsk = hsk or 0
                    total_seconds = total_seconds or 0

                    # Convert seconds to MM:SS format
                    minutes = int(total_seconds // 60)
                    seconds = int(total_seconds % 60)
                    time_display = f"{minutes}:{seconds:02d}"

                    # Calculate time dead
                    time_dead_seconds = int(total_time_dead or 0)
                    dead_minutes = int(time_dead_seconds // 60)
                    dead_seconds = int(time_dead_seconds % 60)
                    time_dead_display = f"{dead_minutes}:{dead_seconds:02d}"

                    # Calculate metrics
                    kd_ratio = kills / deaths if deaths > 0 else kills
                    acc = (hits / shots * 100) if shots and shots > 0 else 0
                    # HSK rate = headshot kills / total kills
                    hsk_rate = (hsk / kills * 100) if kills and kills > 0 else 0
                    # HS rate = headshots / hits
                    hs_rate = (total_hs / hits * 100) if hits and hits > 0 else 0

                    medal = medals[i] if i < len(medals) else f"{i + 1}."
                    top_text += f"{medal} **{name}**\n"
                    # Line 1: Core combat stats
                    top_text += (
                        f"`{kills}K/{deaths}D ({kd_ratio:.2f})` ‚Ä¢ "
                        f"`{dpm:.0f} DPM` ‚Ä¢ "
                        f"`{acc:.1f}% ACC ({hits}/{shots})`\n"
                    )
                    # Line 2: Advanced stats with time alive and time dead
                    top_text += (
                        f"`{hsk} HSK ({hsk_rate:.1f}%)` ‚Ä¢ "
                        f"`{total_hs} HS ({hs_rate:.1f}%)` ‚Ä¢ "
                        f"‚è±Ô∏è `{time_display}` ‚Ä¢ üíÄ `{time_dead_display}`\n\n"
                    )

                embed1.add_field(name="üèÜ All Players", value=top_text.rstrip(), inline=False)

            embed1.set_footer(text=f"Session: {latest_date}")
            await ctx.send(embed=embed1)
            await asyncio.sleep(2)  # Rate limit protection

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # GENERATE BEAUTIFUL SESSION OVERVIEW IMAGE
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                from image_generator import StatsImageGenerator

                generator = StatsImageGenerator()

                # Prepare session data
                session_info = {
                    'date': latest_date,
                    'maps': maps_played,
                    'rounds': rounds_played,
                    'players': player_count,
                }

                # Prepare all players data (use top 5 for image)
                top_players_data = []
                for player in all_players[:5]:
                    name, kills, deaths, dpm, hits, shots = player[0:6]
                    total_hs, hsk, total_seconds, total_time_dead = player[6:10]

                    kd_ratio = kills / deaths if deaths and deaths > 0 else (kills or 0)
                    acc = (hits / shots * 100) if shots and shots > 0 else 0
                    hsk_rate = (hsk / kills * 100) if kills and kills > 0 else 0
                    hs_rate = (total_hs / hits * 100) if hits and hits > 0 else 0

                    # Convert seconds to minutes for playtime display
                    playtime_minutes = (total_seconds or 0) / 60.0

                    top_players_data.append(
                        {
                            'name': name,
                            'kills': kills,
                            'deaths': deaths,
                            'kd': kd_ratio,
                            'dpm': dpm,
                            'acc': acc,
                            'hits': hits,
                            'shots': shots,
                            'hsk': hsk,
                            'hsk_rate': hsk_rate,
                            'hs': total_hs,
                            'hs_rate': hs_rate,
                            'playtime': playtime_minutes,
                        }
                    )

                # Prepare team data for image
                team_data_for_img = {'team1': {}, 'team2': {}}

                for team, kills, deaths, damage in team_stats:
                    kd = kills / deaths if deaths > 0 else kills
                    team_info = {'kills': kills, 'deaths': deaths, 'kd': kd, 'damage': damage}

                    if team == 1:
                        team_data_for_img['team1'] = team_info
                        if team_1_mvp_stats:
                            p, k, dpm, d, revived, gibs = team_1_mvp_stats
                            team_data_for_img['team1']['mvp'] = {
                                'name': p,
                                'kd': k / d if d else k,
                                'dpm': dpm,
                            }
                    elif team == 2:
                        team_data_for_img['team2'] = team_info
                        if team_2_mvp_stats:
                            p, k, dpm, d, revived, gibs = team_2_mvp_stats
                            team_data_for_img['team2']['mvp'] = {
                                'name': p,
                                'kd': k / d if d else k,
                                'dpm': dpm,
                            }

                # Generate the beautiful image!
                img_buf = generator.create_session_overview(
                    session_info, top_players_data, team_data_for_img, (team_1_name, team_2_name)
                )

                file = discord.File(img_buf, filename='session_overview.png')
                await ctx.send("üé® **Session Overview**", file=file)

            except Exception as e:
                logger.error(f"Error generating session image: {e}", exc_info=True)

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 2: Team Analytics
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            embed2 = discord.Embed(
                title=f"‚öîÔ∏è Team Analytics - {team_1_name} vs {team_2_name}",
                description="Comprehensive team performance comparison",
                color=0xED4245,
                timestamp=datetime.now(),
            )

            # Team stats - separate fields for each team for better readability
            if len(team_stats) > 1:
                for team, kills, deaths, damage in team_stats:
                    if team == 1:
                        current_team_name = team_1_name
                        emoji = "üî¥"
                    elif team == 2:
                        current_team_name = team_2_name
                        emoji = "üîµ"
                    else:
                        continue

                    kd_ratio = kills / deaths if deaths > 0 else kills

                    team_text = (
                        f"**Total Kills:** `{kills:,}`\n"
                        f"**Total Deaths:** `{deaths:,}`\n"
                        f"**K/D Ratio:** `{kd_ratio:.2f}`\n"
                        f"**Total Damage:** `{damage:,}`\n"
                    )

                    embed2.add_field(
                        name=f"{emoji} {current_team_name} Team Stats", value=team_text, inline=True
                    )

            # Team MVPs (using pre-fetched stats)
            if team_1_mvp_stats:
                player, kills, dpm, deaths, revives, gibs = team_1_mvp_stats
                kd = kills / deaths if deaths else kills
                team_1_mvp_text = (
                    f"**{player}**\n"
                    f"üíÄ `{kd:.1f} K/D` ({kills}K/{deaths}D)\n"
                    f"üí• `{dpm:.0f} DPM`\n"
                    f"üíâ `{revives} Teammates Revived` ‚Ä¢ ü¶¥ `{gibs} Gibs`"
                )
                embed2.add_field(name=f"üî¥ {team_1_name} MVP", value=team_1_mvp_text, inline=True)

            if team_2_mvp_stats:
                player, kills, dpm, deaths, revives, gibs = team_2_mvp_stats
                kd = kills / deaths if deaths else kills
                team_2_mvp_text = (
                    f"**{player}**\n"
                    f"üíÄ `{kd:.1f} K/D` ({kills}K/{deaths}D)\n"
                    f"üí• `{dpm:.0f} DPM`\n"
                    f"üíâ `{revives} Teammates Revived` ‚Ä¢ ü¶¥ `{gibs} Gibs`"
                )
                embed2.add_field(name=f"üîµ {team_2_name} MVP", value=team_2_mvp_text, inline=True)

            embed2.set_footer(text=f"Session: {latest_date}")
            await ctx.send(embed=embed2)
            await asyncio.sleep(4)  # Rate limit protection

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 3: Team Composition
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            embed3 = discord.Embed(
                title="üë• Team Composition",
                description=(
                    f"Player roster for {team_1_name} vs {team_2_name}\n"
                    f"üîÑ indicates players who swapped teams during session"
                ),
                color=0x57F287,
                timestamp=datetime.now(),
            )

            # üéØ Organize players by team (using hardcoded teams if available)
            team_1_players = []
            team_2_players = []

            if hardcoded_teams:
                # ‚úÖ Use hardcoded team assignments
                team_1_players = [(name, 1, False) for name in team_1_players_list]
                team_2_players = [(name, 1, False) for name in team_2_players_list]
            else:
                # ‚ùå Fall back to Axis/Allies grouping
                for player, teams in player_teams.items():
                    primary_team, primary_rounds = teams[0]

                    if primary_team == 1:
                        team_1_players.append((player, primary_rounds, len(teams) > 1))
                    elif primary_team == 2:
                        team_2_players.append((player, primary_rounds, len(teams) > 1))

                team_1_players.sort(key=lambda x: x[1], reverse=True)
                team_2_players.sort(key=lambda x: x[1], reverse=True)

            # Team 1 roster
            if team_1_players:
                team_1_text = f"**{len(team_1_players)} players**\n\n"
                for i, (player, rounds, swapped) in enumerate(team_1_players[:15], 1):
                    swap_indicator = " üîÑ" if swapped else ""
                    team_1_text += f"{i}. {player}{swap_indicator}\n"
                if len(team_1_players) > 15:
                    more_count = len(team_1_players) - 15
                    team_1_text += f"\n*...and {more_count} more*"
                embed3.add_field(
                    name=f"üî¥ {team_1_name} Roster", value=team_1_text.rstrip(), inline=True
                )

            # Team 2 roster
            if team_2_players:
                team_2_text = f"**{len(team_2_players)} players**\n\n"
                for i, (player, rounds, swapped) in enumerate(team_2_players[:15], 1):
                    swap_indicator = " üîÑ" if swapped else ""
                    team_2_text += f"{i}. {player}{swap_indicator}\n"
                if len(team_2_players) > 15:
                    more_count = len(team_2_players) - 15
                    team_2_text += f"\n*...and {more_count} more*"
                embed3.add_field(
                    name=f"üîµ {team_2_name} Roster", value=team_2_text.rstrip(), inline=True
                )

            # Team swaps (only show if NOT using hardcoded teams OR if actual swaps detected)
            if team_swappers and not hardcoded_teams:
                swap_text = ""
                for player, teams in list(team_swappers.items())[:10]:
                    team_names = []
                    for team, rounds in teams:
                        if team == 1:
                            team_names.append(f"üî¥({rounds}r)")
                        elif team == 2:
                            team_names.append(f"üîµ({rounds}r)")
                    swap_text += f"‚Ä¢ **{player}**: {' ‚Üí '.join(team_names)}\n"
                embed3.add_field(name="üîÑ Team Swaps", value=swap_text.rstrip(), inline=False)
            elif hardcoded_teams and not team_swappers:
                # Show confirmation that no swaps occurred
                embed3.add_field(
                    name="‚úÖ Team Consistency",
                    value="No mid-session player swaps detected",
                    inline=False
                )

            embed3.set_footer(text=f"Session: {latest_date}")
            await ctx.send(embed=embed3)
            await asyncio.sleep(8)  # Rate limit protection

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 4: DPM Analytics
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            embed4 = discord.Embed(
                title="üí• DPM Analytics - Damage Per Minute",
                description="Enhanced DPM with Kill/Death Details",
                color=0xFEE75C,
                timestamp=datetime.now(),
            )

            # DPM Leaderboard with calculation details
            if dpm_leaders:
                dpm_text = ""
                # Get time played for each player to show calculation
                for i, (player, dpm, kills, deaths) in enumerate(dpm_leaders[:10], 1):
                    kd = kills / deaths if deaths else kills
                    dpm_text += f"{i}. **{player}**\n"
                    dpm_text += f"   üí• `{dpm:.0f} DPM` ‚Ä¢ üíÄ `{kd:.1f} K/D` ({kills}K/{deaths}D)\n"

                embed4.add_field(
                    name="üèÜ Enhanced DPM Leaderboard", value=dpm_text.rstrip(), inline=False
                )

            # DPM Insights with calculation formula
            if dpm_leaders:
                avg_dpm = sum(p[1] for p in dpm_leaders) / len(dpm_leaders)
                highest_dpm = dpm_leaders[0][1] if dpm_leaders else 0
                leader_name = dpm_leaders[0][0] if dpm_leaders else "N/A"

                insights = (
                    f"üìä **Enhanced Session DPM Stats:**\n"
                    f"‚Ä¢ Average DPM: `{avg_dpm:.1f}`\n"
                    f"‚Ä¢ Highest DPM: `{highest_dpm:.0f}`\n"
                    f"‚Ä¢ DPM Leader: **{leader_name}**\n"
                    f"‚Ä¢ Formula: `(Total Damage √ó 60) / Time Played (seconds)`"
                )
                embed4.add_field(name="üí• DPM Insights", value=insights, inline=False)

            embed4.set_footer(text="üí• Enhanced with Kill/Death Details")
            await ctx.send(embed=embed4)
            await asyncio.sleep(16)  # Rate limit protection

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 5: Weapon Mastery Breakdown (Text)
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            # Group by player and get their top weapons
            player_weapon_map = {}
            for player, weapon, kills, hits, shots, hs in player_weapons:
                if player not in player_weapon_map:
                    player_weapon_map[player] = []
                acc = (hits / shots * 100) if shots > 0 else 0
                hs_pct = (hs / hits * 100) if hits > 0 else 0
                weapon_clean = weapon.replace('WS_', '').replace('_', ' ').title()
                player_weapon_map[player].append(
                    (weapon_clean, kills, acc, hs_pct, hs, hits, shots)
                )

            # Convert revives data (already fetched before connection closed)
            player_revives = {player: revives for player, revives in player_revives_raw}

            # Sort players by total kills - SHOW ALL PLAYERS
            player_totals = []
            for player, weapons in player_weapon_map.items():
                total_kills = sum(w[1] for w in weapons)
                player_totals.append((player, total_kills))
            player_totals.sort(key=lambda x: x[1], reverse=True)

            # Create text-based weapon breakdown
            embed5 = discord.Embed(
                title="üî´ Weapon Mastery Breakdown",
                description="Top weapons and combat statistics",
                color=0x5865F2,
                timestamp=datetime.now(),
            )

            # Show ALL players and ALL their weapons (not just top 3)
            for player, total_kills in player_totals:
                weapons = player_weapon_map[player]  # ALL weapons
                revives = player_revives.get(player, 0)

                weapon_text = ""
                for weapon, kills, acc, hs_pct, hs, hits, shots in weapons:
                    weapon_text += f"**{weapon}**: `{kills}K` ‚Ä¢ `{
                        acc:.1f}% ACC` ‚Ä¢ `{hs} HS ({
                        hs_pct:.1f}%)`\n"

                # Add revives info
                if revives > 0:
                    weapon_text += f"\nüíâ **Teammates Revived**: `{revives}`"

                embed5.add_field(
                    name=f"{player} ({total_kills} total kills)", value=weapon_text, inline=False
                )

            embed5.set_footer(text=f"Session: {latest_date}")
            await ctx.send(embed=embed5)
            await asyncio.sleep(2)

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 6: Objective & Support Stats
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Use awards_data that was already fetched before connection closed
            if awards_data:
                embed6 = discord.Embed(
                    title="üéØ Objective & Support Stats",
                    description="Comprehensive battlefield contributions",
                    color=0x00D166,
                    timestamp=datetime.now(),
                )

                # Aggregate stats across all rounds per player
                # awards_data format: (clean_name, xp, kill_assists, obj_stolen, obj_returned,
                #                      dyn_planted, dyn_defused, times_revived, double, triple, quad,
                #                      multi, mega, denied_time, useful_kills, useless_kills, gibs,
                #                      best_spree, worst_spree)
                player_objectives = {}
                for row in awards_data:
                    player_name = row[0]
                    if player_name not in player_objectives:
                        player_objectives[player_name] = {
                            'xp': 0,
                            'assists': 0,
                            'obj_stolen': 0,
                            'obj_returned': 0,
                            'dyn_planted': 0,
                            'dyn_defused': 0,
                            'revived': 0,
                            'multi_2x': 0,
                            'multi_3x': 0,
                            'multi_4x': 0,
                            'multi_5x': 0,
                            'multi_6x': 0,
                            'denied_time': 0,
                            'useful_kills': 0,
                            'useless_kills': 0,
                            'gibs': 0,
                            'best_spree': 0,
                            'worst_spree': 0,
                        }

                    # Accumulate stats from each round
                    player_objectives[player_name]['xp'] += row[1] or 0
                    player_objectives[player_name]['assists'] += row[2] or 0
                    player_objectives[player_name]['obj_stolen'] += row[3] or 0
                    player_objectives[player_name]['obj_returned'] += row[4] or 0
                    player_objectives[player_name]['dyn_planted'] += row[5] or 0
                    player_objectives[player_name]['dyn_defused'] += row[6] or 0
                    player_objectives[player_name]['revived'] += row[7] or 0
                    player_objectives[player_name]['multi_2x'] += row[8] or 0
                    player_objectives[player_name]['multi_3x'] += row[9] or 0
                    player_objectives[player_name]['multi_4x'] += row[10] or 0
                    player_objectives[player_name]['multi_5x'] += row[11] or 0
                    player_objectives[player_name]['multi_6x'] += row[12] or 0
                    player_objectives[player_name]['denied_time'] += row[13] or 0
                    player_objectives[player_name]['useful_kills'] += row[14] or 0
                    player_objectives[player_name]['useless_kills'] += row[15] or 0
                    player_objectives[player_name]['gibs'] += row[16] or 0
                    # Track best spree (max) and worst spree (max deaths)
                    player_objectives[player_name]['best_spree'] = max(
                        player_objectives[player_name]['best_spree'], row[17] or 0
                    )
                    player_objectives[player_name]['worst_spree'] = max(
                        player_objectives[player_name]['worst_spree'], row[18] or 0
                    )

                # Sort players by XP and show top 6
                sorted_players = sorted(
                    player_objectives.items(), key=lambda x: x[1]['xp'], reverse=True
                )[:6]

                for i, (player, stats) in enumerate(sorted_players, 1):
                    obj_text = f"**XP:** `{stats['xp']}`\n"
                    obj_text += f"**Assists:** `{stats['assists']}`\n"

                    # Objectives
                    if stats['obj_stolen'] > 0 or stats['obj_returned'] > 0:
                        obj_text += (
                            f"**Objectives:** `{stats['obj_stolen']}/{stats['obj_returned']}` S/R\n"
                        )

                    # Dynamites
                    if stats['dyn_planted'] > 0 or stats['dyn_defused'] > 0:
                        obj_text += (
                            f"**Dynamites:** `{stats['dyn_planted']}/{stats['dyn_defused']}` P/D\n"
                        )

                    # Revived
                    if stats['revived'] > 0:
                        obj_text += f"**Revived:** `{stats['revived']}` times\n"

                    # üî• ADVANCED STATS üî•
                    # Killing spree
                    if stats['best_spree'] >= 3:
                        obj_text += f"üî• **Best Spree:** `{stats['best_spree']}` kills\n"

                    # Death spree (embarrassing!)
                    if stats['worst_spree'] >= 3:
                        obj_text += f"üíÄ **Death Spree:** `{stats['worst_spree']}` deaths\n"

                    # Gibs
                    if stats['gibs'] > 0:
                        obj_text += f"ü¶¥ **Gibs:** `{stats['gibs']}`\n"

                    # Useful kills
                    if stats['useful_kills'] > 0:
                        obj_text += f"‚úÖ **Useful Kills:** `{stats['useful_kills']}`\n"

                    # Useless kills (with clown emoji!)
                    if stats['useless_kills'] > 0:
                        obj_text += f"ü§° **Useless Kills:** `{stats['useless_kills']}`\n"

                    # Denied playtime (convert seconds to MM:SS)
                    if stats['denied_time'] > 0:
                        denied_mins = stats['denied_time'] // 60
                        denied_secs = stats['denied_time'] % 60
                        obj_text += f"‚è±Ô∏è **Enemy Denied:** `{denied_mins}:{denied_secs:02d}`\n"

                    # Multikills with fancy emojis
                    multikills = []
                    if stats['multi_2x'] > 0:
                        multikills.append(f"2Ô∏è‚É£‚úñÔ∏è {stats['multi_2x']}")
                    if stats['multi_3x'] > 0:
                        multikills.append(f"3Ô∏è‚É£‚úñÔ∏è {stats['multi_3x']}")
                    if stats['multi_4x'] > 0:
                        multikills.append(f"4Ô∏è‚É£‚úñÔ∏è {stats['multi_4x']}")
                    if stats['multi_5x'] > 0:
                        multikills.append(f"5Ô∏è‚É£‚úñÔ∏è {stats['multi_5x']}")
                    if stats['multi_6x'] > 0:
                        multikills.append(f"6Ô∏è‚É£‚úñÔ∏è {stats['multi_6x']}")
                    if multikills:
                        obj_text += f"üí• **Multikills:** {' '.join(multikills)}\n"

                    embed6.add_field(name=f"{i}. {player}", value=obj_text.rstrip(), inline=True)

                embed6.set_footer(text="üéØ S/R = Stolen/Returned | P/D = Planted/Defused")
                await ctx.send(embed=embed6)
                await asyncio.sleep(2)  # Rate limit before awards

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 7: SPECIAL AWARDS üèÜ
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            logger.info("üèÜ Calculating Special Awards...")

            # Calculate awards from chaos_awards_data
            awards = {
                'teamkill_king': {'player': None, 'value': 0},
                'selfkill_master': {'player': None, 'value': 0},
                'kill_thief': {'player': None, 'value': 0},
                'spray_pray': {'player': None, 'value': 0},
                'trigger_shy': {'player': None, 'value': 999999},
                'damage_king': {'player': None, 'value': 0},
                'glass_cannon': {'player': None, 'value': 0},
                'engineer': {'player': None, 'value': 0},
                'tank_shield': {'player': None, 'value': 0},
                'respawn_king': {'player': None, 'value': 0},
                'useless_king': {'player': None, 'value': 0},
                'death_magnet': {'player': None, 'value': 0},
                'worst_spree': {'player': None, 'value': 0},
            }

            for row in chaos_awards_data:
                name = row[0]
                teamkills, selfkills, steals, bullets = row[1:5]
                kills, deaths, dmg_given, dmg_received = row[5:9]
                constructions, tank, useless = row[9:12]
                worst_spree, play_time = row[12:14]

                # Teamkill King
                if teamkills > awards['teamkill_king']['value']:
                    awards['teamkill_king'] = {'player': name, 'value': teamkills}

                # Self-Kill Master
                if selfkills > awards['selfkill_master']['value']:
                    awards['selfkill_master'] = {'player': name, 'value': selfkills}

                # Kill Thief
                if steals > awards['kill_thief']['value']:
                    awards['kill_thief'] = {'player': name, 'value': steals}

                # Spray & Pray (most bullets per kill)
                if kills > 0:
                    bpk = bullets / kills
                    if bpk > awards['spray_pray']['value']:
                        awards['spray_pray'] = {'player': name, 'value': bpk}

                # Too Scared to Shoot (fewest bullets, min 5 kills)
                if kills >= 5 and bullets < awards['trigger_shy']['value']:
                    awards['trigger_shy'] = {'player': name, 'value': bullets}

                # Damage Efficiency King (best dmg given/received ratio)
                if dmg_received > 0:
                    eff = dmg_given / dmg_received
                    if eff > awards['damage_king']['value']:
                        awards['damage_king'] = {'player': name, 'value': eff}

                # Glass Cannon (most damage taken)
                if dmg_received > awards['glass_cannon']['value']:
                    awards['glass_cannon'] = {'player': name, 'value': dmg_received}

                # Chief Engineer
                if constructions > awards['engineer']['value']:
                    awards['engineer'] = {'player': name, 'value': constructions}

                # Tank Shield
                if tank > awards['tank_shield']['value']:
                    awards['tank_shield'] = {'player': name, 'value': tank}

                # Respawn King (most deaths)
                if deaths > awards['respawn_king']['value']:
                    awards['respawn_king'] = {'player': name, 'value': deaths}

                # Most Useless Kills
                if useless > awards['useless_king']['value']:
                    awards['useless_king'] = {'player': name, 'value': useless}

                # Death Magnet (most total deaths)
                if deaths > awards['death_magnet']['value']:
                    awards['death_magnet'] = {'player': name, 'value': deaths}

                # Worst Death Spree
                if worst_spree > awards['worst_spree']['value']:
                    awards['worst_spree'] = {'player': name, 'value': worst_spree}

            # Build awards embed
            embed7 = discord.Embed(
                title="üèÜ SESSION SPECIAL AWARDS üèÜ",
                description="*Celebrating excellence... and chaos!*",
                color=0xFFD700,  # Gold
            )

            awards_text = []

            # Positive awards
            if awards['damage_king']['value'] > 1.5:
                player = awards['damage_king']['player']
                ratio = awards['damage_king']['value']
                awards_text.append(
                    f"üí• **Damage Efficiency King:** `{player}` ({ratio:.2f}x ratio)"
                )

            if awards['engineer']['value'] >= 1:
                player = awards['engineer']['player']
                count = int(awards['engineer']['value'])
                awards_text.append(f"üîß **Chief Engineer:** `{player}` ({count} repairs)")

            # Funny/Chaos awards
            if awards['teamkill_king']['value'] >= 2:
                player = awards['teamkill_king']['player']
                count = int(awards['teamkill_king']['value'])
                awards_text.append(f"üî• **Friendly Fire King:** `{player}` ({count} teamkills)")

            if awards['selfkill_master']['value'] >= 3:
                player = awards['selfkill_master']['player']
                count = int(awards['selfkill_master']['value'])
                awards_text.append(f"ü§¶ **Self-Destruct Master:** `{player}` ({count} self-kills!)")

            if awards['kill_thief']['value'] >= 2:
                player = awards['kill_thief']['player']
                count = int(awards['kill_thief']['value'])
                awards_text.append(f"ü•∑ **Kill Thief:** `{player}` ({count} steals)")

            if awards['spray_pray']['value'] >= 100:
                player = awards['spray_pray']['player']
                bpk = awards['spray_pray']['value']
                awards_text.append(f"üéØ **Spray & Pray:** `{player}` ({bpk:.0f} bullets/kill)")

            if awards['trigger_shy']['value'] < 999999:
                player = awards['trigger_shy']['player']
                bullets = int(awards['trigger_shy']['value'])
                awards_text.append(
                    f"üôà **Trigger Discipline:** `{player}` ({bullets} bullets only)"
                )

            if awards['respawn_king']['value'] >= 15:
                player = awards['respawn_king']['player']
                count = int(awards['respawn_king']['value'])
                awards_text.append(f"üíÄ **Respawn Champion:** `{player}` ({count} deaths)")

            if awards['worst_spree']['value'] >= 5:
                player = awards['worst_spree']['player']
                count = int(awards['worst_spree']['value'])
                awards_text.append(
                    f"‚ö∞Ô∏è **Death Spree Record:** `{player}` ({count} deaths in a row)"
                )

            if awards['useless_king']['value'] >= 3:
                player = awards['useless_king']['player']
                count = int(awards['useless_king']['value'])
                awards_text.append(f"ü§° **Most Useless Kills:** `{player}` ({count} useless)")

            if awards['glass_cannon']['value'] >= 1000:
                player = awards['glass_cannon']['player']
                dmg = int(awards['glass_cannon']['value'])
                awards_text.append(f"ü©π **Damage Sponge:** `{player}` ({dmg:,} dmg taken)")

            if awards['tank_shield']['value'] > 0:
                player = awards['tank_shield']['player']
                val = awards['tank_shield']['value']
                awards_text.append(f"üõ°Ô∏è **Tank Shield:** `{player}` ({val:.1f} tank hits)")

            if awards_text:
                embed7.description = "\n".join(awards_text)
            else:
                embed7.description = "*No notable awards this session*"

            embed7.set_footer(text="üéâ Keep up the good work... or not!")
            await ctx.send(embed=embed7)
            await asyncio.sleep(2)

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 8: CHAOS STATS LEADERBOARDS üíÄ
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            logger.info("üíÄ Building Chaos Stats Leaderboards...")

            # Sort chaos_awards_data for leaderboards
            teamkill_leaders = sorted(
                [(r[0], r[1]) for r in chaos_awards_data if r[1] > 0],
                key=lambda x: x[1],
                reverse=True,
            )[:3]

            selfkill_leaders = sorted(
                [(r[0], r[2]) for r in chaos_awards_data if r[2] > 0],
                key=lambda x: x[1],
                reverse=True,
            )[:3]

            killsteal_leaders = sorted(
                [(r[0], r[3]) for r in chaos_awards_data if r[3] > 0],
                key=lambda x: x[1],
                reverse=True,
            )[:3]

            useless_leaders = sorted(
                [(r[0], r[12]) for r in chaos_awards_data if r[12] > 0],
                key=lambda x: x[1],
                reverse=True,
            )[:3]

            death_leaders = sorted(
                [(r[0], r[6]) for r in chaos_awards_data if r[6] > 0],
                key=lambda x: x[1],
                reverse=True,
            )[:3]

            embed8 = discord.Embed(
                title="üíÄ CHAOS & MAYHEM STATS üíÄ",
                description="*The good, the bad, and the ugly*",
                color=0xFF0000,  # Red
            )

            # Teamkills Leaderboard
            if teamkill_leaders:
                tk_text = "\n".join(
                    [
                        f"{'ü•áü•àü•â'[i]} `{name:20s}` - {count} teamkill{'s' if count > 1 else ''}"
                        for i, (name, count) in enumerate(teamkill_leaders)
                    ]
                )
                embed8.add_field(name="üî• Friendly Fire Leaderboard", value=tk_text, inline=False)

            # Self-Kills Leaderboard
            if selfkill_leaders:
                sk_text = "\n".join(
                    [
                        f"{'ü•áü•àü•â'[i]} `{name:20s}` - {count} self-kill{'s' if count > 1 else ''}"
                        for i, (name, count) in enumerate(selfkill_leaders)
                    ]
                )
                embed8.add_field(name="ü§¶ Self-Destruction Champions", value=sk_text, inline=False)

            # Kill Steals Leaderboard
            if killsteal_leaders:
                ks_text = "\n".join(
                    [
                        f"{'ü•áü•àü•â'[i]} `{name:20s}` - {count} steal{'s' if count > 1 else ''}"
                        for i, (name, count) in enumerate(killsteal_leaders)
                    ]
                )
                embed8.add_field(name="ü•∑ Kill Thieves", value=ks_text, inline=False)

            # Useless Kills Leaderboard
            if useless_leaders:
                ul_text = "\n".join(
                    [
                        f"{'ü•áü•àü•â'[i]} `{name:20s}` - {count} useless kill{'s' if count > 1 else ''}"
                        for i, (name, count) in enumerate(useless_leaders)
                    ]
                )
                embed8.add_field(name="ü§° Most Useless Kills", value=ul_text, inline=False)

            # Most Deaths Leaderboard
            if death_leaders:
                dl_text = "\n".join(
                    [
                        f"{'ü•áü•àü•â'[i]} `{name:20s}` - {count} death{'s' if count > 1 else ''}"
                        for i, (name, count) in enumerate(death_leaders)
                    ]
                )
                embed8.add_field(
                    name="üíÄ Respawn Champions (Most Deaths)", value=dl_text, inline=False
                )

            embed8.set_footer(text="üòà Embrace the chaos!")
            await ctx.send(embed=embed8)
            await asyncio.sleep(2)  # Rate limit before graphs

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # MESSAGE 9: Visual Stats Graph
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            logger.info("üé® Generating visual performance graphs...")
            try:
                import matplotlib

                matplotlib.use('Agg')  # Non-interactive backend
                import io

                import matplotlib.pyplot as plt

                # Create a figure with 2 subplots
                fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
                fig.patch.set_facecolor('#2b2d31')

                # Get top 6 players for graphs from all_players data
                # all_players is already sorted by kills DESC
                graph_data = []
                for player in all_players[:6]:  # Top 6 players
                    # Unpack player data
                    # Structure: name, kills, deaths, dpm, hits, shots, total_hs, hs_kills,
                    # seconds, time_dead
                    name = player[0]
                    kills = player[1] or 0
                    deaths = player[2] or 0
                    dpm = player[3] or 0
                    hits = player[4] or 0
                    shots = player[5] or 0

                    acc = (hits / shots * 100) if shots > 0 else 0
                    graph_data.append(
                        {
                            'name': name,
                            'kills': kills,
                            'deaths': deaths,
                            'dpm': dpm,
                            'accuracy': acc,
                        }
                    )

                if graph_data:
                    logger.info(f"üìä Graph data prepared for {len(graph_data)} players")
                    names = [d['name'] for d in graph_data]
                    kills_data = [d['kills'] for d in graph_data]
                    deaths_data = [d['deaths'] for d in graph_data]
                    dpm_data = [d['dpm'] for d in graph_data]

                    # Graph 1: Kills vs Deaths vs DPM
                    x = range(len(names))
                    width = 0.25

                    ax1.bar(
                        [i - width for i in x],
                        kills_data,
                        width,
                        label='Kills',
                        color='#5865f2',
                        alpha=0.8,
                    )
                    ax1.bar(x, deaths_data, width, label='Deaths', color='#ed4245', alpha=0.8)
                    ax1.bar(
                        [i + width for i in x],
                        dpm_data,
                        width,
                        label='DPM',
                        color='#fee75c',
                        alpha=0.8,
                    )

                    ax1.set_ylabel('Value', color='white', fontsize=12)
                    ax1.set_title(
                        'Player Performance - Kills, Deaths, DPM',
                        color='white',
                        fontsize=14,
                        fontweight='bold',
                    )
                    ax1.set_xticks(x)
                    ax1.set_xticklabels(names, rotation=15, ha='right', color='white')
                    ax1.legend(facecolor='#1e1f22', edgecolor='white', labelcolor='white')
                    ax1.set_facecolor('#1e1f22')
                    ax1.tick_params(colors='white')
                    ax1.spines['bottom'].set_color('white')
                    ax1.spines['left'].set_color('white')
                    ax1.spines['top'].set_visible(False)
                    ax1.spines['right'].set_visible(False)
                    ax1.grid(True, alpha=0.2, color='white')

                    # Add value labels on bars
                    for i, (k, d, dpm) in enumerate(zip(kills_data, deaths_data, dpm_data)):
                        ax1.text(
                            i - width,
                            k,
                            str(int(k)),
                            ha='center',
                            va='bottom',
                            color='white',
                            fontsize=9,
                        )
                        ax1.text(
                            i, d, str(int(d)), ha='center', va='bottom', color='white', fontsize=9
                        )
                        ax1.text(
                            i + width,
                            dpm,
                            str(int(dpm)),
                            ha='center',
                            va='bottom',
                            color='white',
                            fontsize=9,
                        )

                    # Graph 2: K/D Ratio and Accuracy
                    kd_ratios = [
                        d['kills'] / d['deaths'] if d['deaths'] > 0 else d['kills']
                        for d in graph_data
                    ]
                    accuracy_data = [d['accuracy'] for d in graph_data]

                    ax2_twin = ax2.twinx()

                    bars1 = ax2.bar(
                        [i - width / 2 for i in x],
                        kd_ratios,
                        width,
                        label='K/D Ratio',
                        color='#57f287',
                        alpha=0.8,
                    )
                    bars2 = ax2_twin.bar(
                        [i + width / 2 for i in x],
                        accuracy_data,
                        width,
                        label='Accuracy %',
                        color='#eb459e',
                        alpha=0.8,
                    )

                    ax2.set_ylabel('K/D Ratio', color='white', fontsize=12)
                    ax2_twin.set_ylabel('Accuracy %', color='white', fontsize=12)
                    ax2.set_title(
                        'Player Efficiency - K/D and Accuracy',
                        color='white',
                        fontsize=14,
                        fontweight='bold',
                    )
                    ax2.set_xticks(x)
                    ax2.set_xticklabels(names, rotation=15, ha='right', color='white')

                    # Combine legends
                    lines1, labels1 = ax2.get_legend_handles_labels()
                    lines2, labels2 = ax2_twin.get_legend_handles_labels()
                    ax2.legend(
                        lines1 + lines2,
                        labels1 + labels2,
                        facecolor='#1e1f22',
                        edgecolor='white',
                        labelcolor='white',
                    )

                    ax2.set_facecolor('#1e1f22')
                    ax2.tick_params(colors='white')
                    ax2_twin.tick_params(colors='white')
                    ax2.spines['bottom'].set_color('white')
                    ax2.spines['left'].set_color('white')
                    ax2_twin.spines['right'].set_color('white')
                    ax2.spines['top'].set_visible(False)
                    ax2.grid(True, alpha=0.2, color='white', axis='y')

                    # Add value labels
                    for i, (kd, acc) in enumerate(zip(kd_ratios, accuracy_data)):
                        ax2.text(
                            i - width / 2,
                            kd,
                            f'{kd:.2f}',
                            ha='center',
                            va='bottom',
                            color='white',
                            fontsize=9,
                        )
                        ax2_twin.text(
                            i + width / 2,
                            acc,
                            f'{acc:.1f}%',
                            ha='center',
                            va='bottom',
                            color='white',
                            fontsize=9,
                        )

                    plt.tight_layout()

                    # Save to bytes buffer
                    buf = io.BytesIO()
                    plt.savefig(
                        buf, format='png', facecolor='#2b2d31', dpi=100, bbox_inches='tight'
                    )
                    buf.seek(0)
                    plt.close()

                    # Send as Discord file
                    file = discord.File(buf, filename='session_stats.png')
                    logger.info("üìä Sending Graph 1 to Discord...")
                    await ctx.send("üìä **Visual Performance Analytics - Part 1**", file=file)
                    logger.info("‚úÖ Graph 1 sent successfully!")
                    await asyncio.sleep(1)

                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    # GRAPH 2: Advanced Combat Stats (Gibs and Damage Only)
                    # NOTE: Revives and Useful Kills disabled - parser not capturing data
                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if advanced_graph_data and len(advanced_graph_data) > 0:
                        logger.info("üé® Generating Graph 2 (Advanced Combat Stats)...")
                        fig2, (ax4, ax6) = plt.subplots(1, 2, figsize=(14, 6))
                        fig2.patch.set_facecolor('#2b2d31')

                        # Extract data (only gibs and damage for now)
                        adv_names = [row[0] for row in advanced_graph_data]
                        gibs = [row[2] or 0 for row in advanced_graph_data]
                        total_damage = [row[4] or 0 for row in advanced_graph_data]

                        x_adv = range(len(adv_names))

                        # Subplot 1: Gibs
                        ax4.barh(x_adv, gibs, color='#ed4245', alpha=0.8)
                        ax4.set_yticks(x_adv)
                        ax4.set_yticklabels(adv_names, color='white')
                        ax4.set_xlabel('Gibs', color='white', fontsize=11)
                        ax4.set_title(
                            'ü¶¥ Gib Masters', color='white', fontsize=12, fontweight='bold'
                        )
                        ax4.set_facecolor('#1e1f22')
                        ax4.tick_params(colors='white')
                        ax4.spines['bottom'].set_color('white')
                        ax4.spines['left'].set_color('white')
                        ax4.spines['top'].set_visible(False)
                        ax4.spines['right'].set_visible(False)
                        ax4.grid(True, alpha=0.2, color='white', axis='x')
                        for i, v in enumerate(gibs):
                            ax4.text(v, i, f' {int(v)}', va='center', color='white', fontsize=9)

                        # Subplot 2: Total Damage
                        ax6.barh(x_adv, total_damage, color='#5865f2', alpha=0.8)
                        ax6.set_yticks(x_adv)
                        ax6.set_yticklabels(adv_names, color='white')
                        ax6.set_xlabel('Total Damage', color='white', fontsize=11)
                        ax6.set_title(
                            'üí• Damage Dealers', color='white', fontsize=12, fontweight='bold'
                        )
                        ax6.set_facecolor('#1e1f22')
                        ax6.tick_params(colors='white')
                        ax6.spines['bottom'].set_color('white')
                        ax6.spines['left'].set_color('white')
                        ax6.spines['top'].set_visible(False)
                        ax6.spines['right'].set_visible(False)
                        ax6.grid(True, alpha=0.2, color='white', axis='x')
                        for i, v in enumerate(total_damage):
                            ax6.text(v, i, f' {int(v)}', va='center', color='white', fontsize=9)

                        plt.tight_layout()

                        # Save and send Graph 2
                        buf2 = io.BytesIO()
                        plt.savefig(
                            buf2, format='png', facecolor='#2b2d31', dpi=100, bbox_inches='tight'
                        )
                        buf2.seek(0)
                        plt.close()

                        file2 = discord.File(buf2, filename='advanced_stats.png')
                        logger.info("üìä Sending Graph 2 to Discord...")
                        await ctx.send("üìä **Advanced Combat Stats - Part 2**", file=file2)
                        logger.info("‚úÖ Graph 2 sent successfully!")
                        await asyncio.sleep(1)

                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    # GRAPH 3: Per-Map Breakdown
                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if per_map_data and len(per_map_data) > 0:
                        logger.info("üé® Generating Graph 3 (Per-Map Breakdown)...")

                        # Group data by map
                        map_stats = {}
                        for row in per_map_data:
                            map_name = row[0]
                            if map_name not in map_stats:
                                map_stats[map_name] = []
                            map_stats[map_name].append(
                                {
                                    'name': row[1],
                                    'kills': row[2] or 0,
                                    'deaths': row[3] or 0,
                                    'dpm': row[4] or 0,
                                }
                            )

                        # Create figure with subplots for each map (max 4 maps)
                        num_maps = min(len(map_stats), 4)
                        if num_maps > 0:
                            fig3, axes = plt.subplots(2, 2, figsize=(16, 12))
                            fig3.patch.set_facecolor('#2b2d31')
                            axes_flat = axes.flatten() if num_maps > 1 else [axes]

                            for idx, (map_name, players) in enumerate(list(map_stats.items())[:4]):
                                ax = axes_flat[idx]

                                # Get top 5 players for this map
                                top_players = sorted(
                                    players, key=lambda x: x['kills'], reverse=True
                                )[:5]
                                map_player_names = [p['name'] for p in top_players]
                                map_kills = [p['kills'] for p in top_players]
                                map_deaths = [p['deaths'] for p in top_players]
                                map_dpm = [p['dpm'] for p in top_players]

                                x_map = range(len(map_player_names))
                                width_map = 0.25

                                # Triple bar chart (Kills, Deaths, DPM)
                                ax.bar(
                                    [i - width_map for i in x_map],
                                    map_kills,
                                    width_map,
                                    label='Kills',
                                    color='#5865f2',
                                    alpha=0.8,
                                )
                                ax.bar(
                                    x_map,
                                    map_deaths,
                                    width_map,
                                    label='Deaths',
                                    color='#ed4245',
                                    alpha=0.8,
                                )
                                ax.bar(
                                    [i + width_map for i in x_map],
                                    map_dpm,
                                    width_map,
                                    label='DPM',
                                    color='#fee75c',
                                    alpha=0.8,
                                )

                                ax.set_title(
                                    f'üó∫Ô∏è {map_name}', color='white', fontsize=12, fontweight='bold'
                                )
                                ax.set_xticks(x_map)
                                ax.set_xticklabels(
                                    map_player_names,
                                    rotation=20,
                                    ha='right',
                                    color='white',
                                    fontsize=8,
                                )
                                ax.set_facecolor('#1e1f22')
                                ax.tick_params(colors='white')
                                ax.spines['bottom'].set_color('white')
                                ax.spines['left'].set_color('white')
                                ax.spines['top'].set_visible(False)
                                ax.spines['right'].set_visible(False)
                                ax.grid(True, alpha=0.2, color='white', axis='y')
                                ax.legend(
                                    facecolor='#1e1f22',
                                    edgecolor='white',
                                    labelcolor='white',
                                    fontsize=8,
                                )

                            # Hide unused subplots
                            for idx in range(num_maps, 4):
                                axes_flat[idx].set_visible(False)

                            plt.tight_layout()

                            # Save and send Graph 3
                            buf3 = io.BytesIO()
                            plt.savefig(
                                buf3,
                                format='png',
                                facecolor='#2b2d31',
                                dpi=100,
                                bbox_inches='tight',
                            )
                            buf3.seek(0)
                            plt.close()

                            file3 = discord.File(buf3, filename='per_map_breakdown.png')
                            logger.info("üìä Sending Graph 3 to Discord...")
                            await ctx.send(
                                "üìä **Per-Map Performance Breakdown - Part 3**", file=file3
                            )
                            logger.info("‚úÖ Graph 3 sent successfully!")
                            await asyncio.sleep(1)

                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    # GRAPH 4: Combat Efficiency & Bullets Analysis
                    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                    if chaos_awards_data and len(chaos_awards_data) > 0:
                        logger.info("üé® Generating Graph 4 (Combat Efficiency)...")

                        # Get top 8 players by total kills for efficiency analysis
                        efficiency_players = sorted(
                            chaos_awards_data, key=lambda x: x[5], reverse=True  # total_kills
                        )[:8]

                        if efficiency_players:
                            fig4, ((ax7, ax8), (ax9, ax10)) = plt.subplots(2, 2, figsize=(16, 12))
                            fig4.patch.set_facecolor('#2b2d31')

                            # Extract data
                            eff_names = [row[0] for row in efficiency_players]
                            eff_dmg_given = [row[7] or 0 for row in efficiency_players]
                            eff_dmg_received = [row[8] or 0 for row in efficiency_players]
                            eff_bullets = [row[4] or 0 for row in efficiency_players]
                            eff_kills = [row[5] or 0 for row in efficiency_players]

                            # Calculate ratios
                            eff_damage_ratio = [
                                (g / r) if r > 0 else g
                                for g, r in zip(eff_dmg_given, eff_dmg_received)
                            ]
                            eff_bullets_per_kill = [
                                (b / k) if k > 0 else 0 for b, k in zip(eff_bullets, eff_kills)
                            ]

                            x_eff = range(len(eff_names))
                            width_eff = 0.35

                            # Subplot 1: Damage Given vs Received
                            ax7.bar(
                                [i - width_eff / 2 for i in x_eff],
                                eff_dmg_given,
                                width_eff,
                                label='Damage Given',
                                color='#5865f2',
                                alpha=0.8,
                            )
                            ax7.bar(
                                [i + width_eff / 2 for i in x_eff],
                                eff_dmg_received,
                                width_eff,
                                label='Damage Received',
                                color='#ed4245',
                                alpha=0.8,
                            )
                            ax7.set_xticks(x_eff)
                            ax7.set_xticklabels(
                                eff_names, rotation=20, ha='right', color='white', fontsize=9
                            )
                            ax7.set_ylabel('Damage', color='white', fontsize=11)
                            ax7.set_title(
                                'Damage Given vs Received',
                                color='white',
                                fontsize=12,
                                fontweight='bold',
                            )
                            ax7.set_facecolor('#1e1f22')
                            ax7.tick_params(colors='white')
                            ax7.spines['bottom'].set_color('white')
                            ax7.spines['left'].set_color('white')
                            ax7.spines['top'].set_visible(False)
                            ax7.spines['right'].set_visible(False)
                            ax7.grid(True, alpha=0.2, color='white', axis='y')
                            ax7.legend(
                                facecolor='#1e1f22',
                                edgecolor='white',
                                labelcolor='white',
                                fontsize=9,
                            )

                            # Subplot 2: Damage Efficiency Ratio
                            colors_ratio = [
                                '#57f287' if r > 1.5 else '#fee75c' if r > 1.0 else '#ed4245'
                                for r in eff_damage_ratio
                            ]
                            ax8.bar(x_eff, eff_damage_ratio, color=colors_ratio, alpha=0.8)
                            ax8.axhline(
                                y=1.0, color='white', linestyle='--', alpha=0.5, linewidth=1
                            )
                            ax8.set_xticks(x_eff)
                            ax8.set_xticklabels(
                                eff_names, rotation=20, ha='right', color='white', fontsize=9
                            )
                            ax8.set_ylabel('Ratio (Given/Received)', color='white', fontsize=11)
                            ax8.set_title(
                                'Damage Efficiency Ratio',
                                color='white',
                                fontsize=12,
                                fontweight='bold',
                            )
                            ax8.set_facecolor('#1e1f22')
                            ax8.tick_params(colors='white')
                            ax8.spines['bottom'].set_color('white')
                            ax8.spines['left'].set_color('white')
                            ax8.spines['top'].set_visible(False)
                            ax8.spines['right'].set_visible(False)
                            ax8.grid(True, alpha=0.2, color='white', axis='y')
                            for i, v in enumerate(eff_damage_ratio):
                                ax8.text(
                                    i,
                                    v,
                                    f'{v:.2f}x',
                                    ha='center',
                                    va='bottom',
                                    color='white',
                                    fontsize=8,
                                )

                            # Subplot 3: Total Bullets Fired
                            ax9.bar(x_eff, eff_bullets, color='#fee75c', alpha=0.8)
                            ax9.set_xticks(x_eff)
                            ax9.set_xticklabels(
                                eff_names, rotation=20, ha='right', color='white', fontsize=9
                            )
                            ax9.set_ylabel('Bullets Fired', color='white', fontsize=11)
                            ax9.set_title(
                                'Total Ammunition Fired',
                                color='white',
                                fontsize=12,
                                fontweight='bold',
                            )
                            ax9.set_facecolor('#1e1f22')
                            ax9.tick_params(colors='white')
                            ax9.spines['bottom'].set_color('white')
                            ax9.spines['left'].set_color('white')
                            ax9.spines['top'].set_visible(False)
                            ax9.spines['right'].set_visible(False)
                            ax9.grid(True, alpha=0.2, color='white', axis='y')
                            for i, v in enumerate(eff_bullets):
                                ax9.text(
                                    i,
                                    v,
                                    f'{int(v):,}',
                                    ha='center',
                                    va='bottom',
                                    color='white',
                                    fontsize=8,
                                )

                            # Subplot 4: Bullets per Kill
                            colors_bpk = [
                                '#57f287' if b < 100 else '#fee75c' if b < 200 else '#ed4245'
                                for b in eff_bullets_per_kill
                            ]
                            ax10.bar(x_eff, eff_bullets_per_kill, color=colors_bpk, alpha=0.8)
                            ax10.set_xticks(x_eff)
                            ax10.set_xticklabels(
                                eff_names, rotation=20, ha='right', color='white', fontsize=9
                            )
                            ax10.set_ylabel('Bullets per Kill', color='white', fontsize=11)
                            ax10.set_title(
                                'Accuracy Metric (Lower = Better)',
                                color='white',
                                fontsize=12,
                                fontweight='bold',
                            )
                            ax10.set_facecolor('#1e1f22')
                            ax10.tick_params(colors='white')
                            ax10.spines['bottom'].set_color('white')
                            ax10.spines['left'].set_color('white')
                            ax10.spines['top'].set_visible(False)
                            ax10.spines['right'].set_visible(False)
                            ax10.grid(True, alpha=0.2, color='white', axis='y')
                            for i, v in enumerate(eff_bullets_per_kill):
                                ax10.text(
                                    i,
                                    v,
                                    f'{v:.0f}',
                                    ha='center',
                                    va='bottom',
                                    color='white',
                                    fontsize=8,
                                )

                            plt.tight_layout()

                            # Save and send Graph 4
                            buf4 = io.BytesIO()
                            plt.savefig(
                                buf4,
                                format='png',
                                facecolor='#2b2d31',
                                dpi=100,
                                bbox_inches='tight',
                            )
                            buf4.seek(0)
                            plt.close()

                            file4 = discord.File(buf4, filename='combat_efficiency.png')
                            logger.info("üìä Sending Graph 4 to Discord...")
                            await ctx.send(
                                "üìä **Combat Efficiency & Bullets Analysis - Part 4**", file=file4
                            )
                            logger.info("‚úÖ Graph 4 sent successfully!")

                else:
                    logger.warning("‚ö†Ô∏è No graph data available - empty graph_data list")

            except ImportError as e:
                logger.warning(f"‚ö†Ô∏è matplotlib not installed: {e}")
            except Exception as e:
                logger.error(f"‚ùå Error generating graphs: {e}", exc_info=True)
                # Send error message to user
                await ctx.send(f"‚ö†Ô∏è Could not generate graphs: {str(e)[:100]}")

        except Exception as e:
            logger.error(f"Error in last_session command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error retrieving last session: {e}")

    @commands.command(name='link')
    async def link(self, ctx, target: str = None, *, guid: str = None):
        """üîó Link your Discord account to your in-game profile

        Usage: 
        - !link                        ‚Üí Smart search with top 3 suggestions
        - !link YourPlayerName         ‚Üí Search by name
        - !link GUID                   ‚Üí Direct link by GUID
        - !link @user GUID             ‚Üí Admin: Link another user (requires permissions)
        """
        try:
            # === SCENARIO 0: ADMIN LINKING (@mention + GUID) ===
            if ctx.message.mentions and guid:
                await self._admin_link(ctx, ctx.message.mentions[0], guid.upper())
                return

            # For self-linking
            discord_id = str(ctx.author.id)

            # Check if already linked
            async with aiosqlite.connect(self.bot.db_path) as db:
                async with db.execute(
                    '''
                    SELECT et_name, et_guid FROM player_links
                    WHERE discord_id = ?
                ''',
                    (discord_id,),
                ) as cursor:
                    existing = await cursor.fetchone()

                if existing:
                    await ctx.send(
                        f"‚ö†Ô∏è You're already linked to **{existing[0]}** (GUID: {existing[1]})\\n"
                        f"Use `!unlink` first to change your linked account."
                    )
                    return

                # === SCENARIO 1: NO ARGUMENTS - Smart Self-Linking ===
                if not target:
                    await self._smart_self_link(ctx, discord_id, db)
                    return

                # === SCENARIO 2: GUID Direct Link ===
                # Check if it's a GUID (8 hex characters)
                if len(target) == 8 and all(c in '0123456789ABCDEFabcdef' for c in target):
                    await self._link_by_guid(ctx, discord_id, target.upper(), db)
                    return

                # === SCENARIO 3: Name Search ===
                await self._link_by_name(ctx, discord_id, target, db)

        except Exception as e:
            logger.error(f"Error in link command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error linking account: {e}")

    async def _smart_self_link(self, ctx, discord_id: str, db):
        """Smart self-linking: show top 3 unlinked GUIDs with aliases"""
        try:
            # Get top 3 unlinked players by recent activity and total stats
            async with db.execute(
                '''
                SELECT 
                    player_guid,
                    MAX(session_date) as last_played,
                    SUM(kills) as total_kills,
                    SUM(deaths) as total_deaths,
                    COUNT(DISTINCT session_id) as games
                FROM player_comprehensive_stats
                WHERE player_guid NOT IN (SELECT et_guid FROM player_links WHERE et_guid IS NOT NULL)
                GROUP BY player_guid
                ORDER BY last_played DESC, total_kills DESC
                LIMIT 3
            ''',
            ) as cursor:
                top_players = await cursor.fetchall()

            if not top_players:
                await ctx.send(
                    "‚ùå No available players found!\\n"
                    "All players are already linked or no games recorded."
                )
                return

            # Build embed with top 3 options
            embed = discord.Embed(
                title="üîç Link Your Account",
                description=(
                    f"Found **{len(top_players)}** potential matches!\\n"
                    f"React with 1Ô∏è‚É£/2Ô∏è‚É£/3Ô∏è‚É£ or use `!select <number>` within 60 seconds."
                ),
                color=0x3498db,
            )

            options_data = []
            for idx, (guid, last_date, kills, deaths, games) in enumerate(top_players, 1):
                # Get aliases for this GUID
                async with db.execute(
                    '''
                    SELECT player_name, last_seen, times_used
                    FROM player_aliases
                    WHERE player_guid = ?
                    ORDER BY last_seen DESC, times_used DESC
                    LIMIT 3
                ''',
                    (guid,),
                ) as cursor:
                    aliases = await cursor.fetchall()

                # Format aliases
                if aliases:
                    primary_name = aliases[0][0]
                    alias_str = ", ".join([a[0] for a in aliases[:3]])
                    if len(aliases) > 3:
                        alias_str += "..."
                else:
                    # Fallback to most recent name
                    async with db.execute(
                        '''
                        SELECT player_name 
                        FROM player_comprehensive_stats 
                        WHERE player_guid = ? 
                        ORDER BY session_date DESC 
                        LIMIT 1
                    ''',
                        (guid,),
                    ) as cursor:
                        name_row = await cursor.fetchone()
                        primary_name = name_row[0] if name_row else "Unknown"
                        alias_str = primary_name

                kd_ratio = kills / deaths if deaths > 0 else kills
                
                emoji = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£"][idx - 1]
                embed.add_field(
                    name=f"{emoji} **{primary_name}**",
                    value=(
                        f"**GUID:** {guid}\\n"
                        f"**Stats:** {kills:,} kills / {deaths:,} deaths / {kd_ratio:.2f} K/D\\n"
                        f"**Games:** {games:,} | **Last Seen:** {last_date}\\n"
                        f"**Also:** {alias_str}"
                    ),
                    inline=False,
                )

                options_data.append({
                    'guid': guid,
                    'name': primary_name,
                    'kills': kills,
                    'games': games
                })

            embed.set_footer(text=f"üí° Tip: Use !link <GUID> to link directly | Requested by {ctx.author.display_name}")

            message = await ctx.send(embed=embed)

            # Add reaction emojis
            emojis = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£'][:len(top_players)]
            for emoji in emojis:
                await message.add_reaction(emoji)

            # Wait for reaction
            def check(reaction, user):
                return (
                    user == ctx.author
                    and str(reaction.emoji) in emojis
                    and reaction.message.id == message.id
                )

            try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                
                # Get selected index
                selected_idx = emojis.index(str(reaction.emoji))
                selected = options_data[selected_idx]

                # Link the account
                await db.execute(
                    '''
                    INSERT OR REPLACE INTO player_links
                    (discord_id, discord_username, et_guid, et_name, linked_date, verified)
                    VALUES (?, ?, ?, ?, datetime('now'), 1)
                ''',
                    (discord_id, str(ctx.author), selected['guid'], selected['name']),
                )
                await db.commit()

                # Success!
                await message.clear_reactions()
                success_embed = discord.Embed(
                    title="‚úÖ Account Linked!",
                    description=f"Successfully linked to **{selected['name']}**",
                    color=0x00FF00,
                )
                success_embed.add_field(
                    name="Stats Preview",
                    value=f"**Games:** {selected['games']:,}\\n**Kills:** {selected['kills']:,}",
                    inline=True,
                )
                success_embed.add_field(
                    name="Quick Access",
                    value="Use `!stats` without arguments to see your stats!",
                    inline=False,
                )
                success_embed.set_footer(text=f"GUID: {selected['guid']}")
                await ctx.send(embed=success_embed)

            except asyncio.TimeoutError:
                await message.clear_reactions()
                await ctx.send("‚è±Ô∏è Link request timed out. Try again with `!link`")

        except Exception as e:
            logger.error(f"Error in smart self-link: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error during self-linking: {e}")

    async def _link_by_guid(self, ctx, discord_id: str, guid: str, db):
        """Direct GUID linking with confirmation"""
        try:
            # Check if GUID exists
            async with db.execute(
                '''
                SELECT 
                    SUM(kills) as total_kills,
                    SUM(deaths) as total_deaths,
                    COUNT(DISTINCT session_id) as games,
                    MAX(session_date) as last_seen
                FROM player_comprehensive_stats
                WHERE player_guid = ?
            ''',
                (guid,),
            ) as cursor:
                stats = await cursor.fetchone()

            if not stats or stats[0] is None:
                await ctx.send(f"‚ùå GUID `{guid}` not found in database.")
                return

            # Get aliases
            async with db.execute(
                '''
                SELECT player_name, last_seen, times_used
                FROM player_aliases
                WHERE player_guid = ?
                ORDER BY last_seen DESC, times_used DESC
                LIMIT 3
            ''',
                (guid,),
            ) as cursor:
                aliases = await cursor.fetchall()

            if aliases:
                primary_name = aliases[0][0]
                alias_str = ", ".join([a[0] for a in aliases[:3]])
            else:
                # Fallback
                async with db.execute(
                    '''
                    SELECT player_name 
                    FROM player_comprehensive_stats 
                    WHERE player_guid = ? 
                    ORDER BY session_date DESC 
                    LIMIT 1
                ''',
                    (guid,),
                ) as cursor:
                    name_row = await cursor.fetchone()
                    primary_name = name_row[0] if name_row else "Unknown"
                    alias_str = primary_name

            kills, deaths, games, last_seen = stats
            kd_ratio = kills / deaths if deaths > 0 else kills

            # Confirmation embed
            embed = discord.Embed(
                title="üîó Confirm Account Link",
                description=f"Link your Discord to **{primary_name}**?",
                color=0xFFA500,
            )
            embed.add_field(
                name="GUID",
                value=guid,
                inline=False,
            )
            embed.add_field(
                name="Known Names",
                value=alias_str,
                inline=False,
            )
            embed.add_field(
                name="Stats",
                value=f"{kills:,} kills / {deaths:,} deaths / {kd_ratio:.2f} K/D",
                inline=True,
            )
            embed.add_field(
                name="Activity",
                value=f"{games:,} games | Last: {last_seen}",
                inline=True,
            )
            embed.set_footer(text="React ‚úÖ to confirm or ‚ùå to cancel (60s)")

            message = await ctx.send(embed=embed)
            await message.add_reaction('‚úÖ')
            await message.add_reaction('‚ùå')

            def check(reaction, user):
                return (
                    user == ctx.author
                    and str(reaction.emoji) in ['‚úÖ', '‚ùå']
                    and reaction.message.id == message.id
                )

            try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)

                if str(reaction.emoji) == '‚úÖ':
                    # Confirmed - link it
                    await db.execute(
                        '''
                        INSERT OR REPLACE INTO player_links
                        (discord_id, discord_username, et_guid, et_name, linked_date, verified)
                        VALUES (?, ?, ?, ?, datetime('now'), 1)
                    ''',
                        (discord_id, str(ctx.author), guid, primary_name),
                    )
                    await db.commit()

                    await message.clear_reactions()
                    await ctx.send(f"‚úÖ Successfully linked to **{primary_name}** (GUID: {guid})")
                else:
                    await message.clear_reactions()
                    await ctx.send("‚ùå Link cancelled.")

            except asyncio.TimeoutError:
                await message.clear_reactions()
                await ctx.send("‚è±Ô∏è Confirmation timed out.")

        except Exception as e:
            logger.error(f"Error in GUID link: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error linking by GUID: {e}")

    async def _link_by_name(self, ctx, discord_id: str, player_name: str, db):
        """Name search linking (existing functionality enhanced)"""
        try:
            # Search in player_aliases first for better matching
            async with db.execute(
                '''
                SELECT DISTINCT pa.player_guid
                FROM player_aliases pa
                WHERE LOWER(pa.clean_name) LIKE LOWER(?)
                ORDER BY pa.last_seen DESC
                LIMIT 5
            ''',
                (f'%{player_name}%',),
            ) as cursor:
                alias_guids = [row[0] for row in await cursor.fetchall()]

            # Also search main stats table
            async with db.execute(
                '''
                SELECT player_guid, player_name,
                       SUM(kills) as total_kills,
                       COUNT(DISTINCT session_id) as games,
                       MAX(session_date) as last_seen
                FROM player_comprehensive_stats
                WHERE LOWER(player_name) LIKE LOWER(?)
                GROUP BY player_guid
                ORDER BY last_seen DESC, games DESC
                LIMIT 5
            ''',
                (f'%{player_name}%',),
            ) as cursor:
                matches = await cursor.fetchall()

            # Combine and deduplicate
            guid_set = set(alias_guids)
            for match in matches:
                guid_set.add(match[0])

            if not guid_set:
                await ctx.send(
                    f"‚ùå No player found matching '{player_name}'\\n"
                    f"üí° Try: `!link` (no arguments) to see all available players"
                )
                return

            # Get full data for found GUIDs
            guid_list = list(guid_set)[:3]  # Limit to 3
            
            if len(guid_list) == 1:
                # Single match - link directly with confirmation
                await self._link_by_guid(ctx, discord_id, guid_list[0], db)
            else:
                # Multiple matches - show options (similar to smart self-link)
                embed = discord.Embed(
                    title=f"üîç Multiple Matches for '{player_name}'",
                    description="React with 1Ô∏è‚É£/2Ô∏è‚É£/3Ô∏è‚É£ to select:",
                    color=0x3498db,
                )

                options_data = []
                for idx, guid in enumerate(guid_list, 1):
                    # Get stats and aliases
                    async with db.execute(
                        '''
                        SELECT SUM(kills), SUM(deaths), COUNT(DISTINCT session_id), MAX(session_date)
                        FROM player_comprehensive_stats
                        WHERE player_guid = ?
                    ''',
                        (guid,),
                    ) as cursor:
                        stats = await cursor.fetchone()

                    async with db.execute(
                        '''
                        SELECT player_name FROM player_aliases
                        WHERE player_guid = ?
                        ORDER BY last_seen DESC LIMIT 1
                    ''',
                        (guid,),
                    ) as cursor:
                        name_row = await cursor.fetchone()
                        name = name_row[0] if name_row else "Unknown"

                    kills, deaths, games, last_seen = stats
                    kd = kills / deaths if deaths > 0 else kills

                    emoji = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£"][idx - 1]
                    embed.add_field(
                        name=f"{emoji} **{name}**",
                        value=f"**GUID:** {guid}\\n{kills:,} kills | {games:,} games | Last: {last_seen}",
                        inline=False,
                    )

                    options_data.append({'guid': guid, 'name': name, 'kills': kills, 'games': games})

                message = await ctx.send(embed=embed)

                emojis = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£'][:len(guid_list)]
                for emoji in emojis:
                    await message.add_reaction(emoji)

                def check(reaction, user):
                    return user == ctx.author and str(reaction.emoji) in emojis and reaction.message.id == message.id

                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)
                    selected_idx = emojis.index(str(reaction.emoji))
                    selected = options_data[selected_idx]

                    await db.execute(
                        '''
                        INSERT OR REPLACE INTO player_links
                        (discord_id, discord_username, et_guid, et_name, linked_date, verified)
                        VALUES (?, ?, ?, ?, datetime('now'), 1)
                    ''',
                        (discord_id, str(ctx.author), selected['guid'], selected['name']),
                    )
                    await db.commit()

                    await message.clear_reactions()
                    await ctx.send(f"‚úÖ Successfully linked to **{selected['name']}** (GUID: {selected['guid']})")

                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    await ctx.send("‚è±Ô∏è Selection timed out.")

        except Exception as e:
            logger.error(f"Error in name link: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error linking by name: {e}")

    async def _admin_link(self, ctx, target_user: discord.User, guid: str):
        """Admin linking: Link another user's Discord to a GUID"""
        try:
            # Check permissions
            if not ctx.author.guild_permissions.manage_guild:
                await ctx.send(
                    "‚ùå You don't have permission to link other users.\\n"
                    "**Required:** Manage Server permission"
                )
                logger.warning(
                    f"Unauthorized admin link attempt by {ctx.author} "
                    f"(ID: {ctx.author.id})"
                )
                return

            # Validate GUID format (8 hex characters)
            if len(guid) != 8 or not all(c in '0123456789ABCDEFabcdef' for c in guid):
                await ctx.send(
                    f"‚ùå Invalid GUID format: `{guid}`\\n"
                    f"**GUIDs must be exactly 8 hexadecimal characters** (e.g., `D8423F90`)\\n\\n"
                    f"üí° To link by player name instead:\\n"
                    f"   ‚Ä¢ Ask {target_user.mention} to use `!link {guid}` (searches by name)\\n"
                    f"   ‚Ä¢ Or use `!stats {guid}` to find their GUID first"
                )
                return

            target_discord_id = str(target_user.id)

            async with aiosqlite.connect(self.bot.db_path) as db:
                # Check if target already linked
                async with db.execute(
                    '''
                    SELECT et_name, et_guid FROM player_links
                    WHERE discord_id = ?
                ''',
                    (target_discord_id,),
                ) as cursor:
                    existing = await cursor.fetchone()

                if existing:
                    await ctx.send(
                        f"‚ö†Ô∏è {target_user.mention} is already linked to "
                        f"**{existing[0]}** (GUID: {existing[1]})\\n"
                        f"They need to `!unlink` first, or you can overwrite "
                        f"with force (react ‚ö†Ô∏è to confirm)."
                    )
                    # For now, just block. Future: Add force option
                    return

                # Validate GUID exists
                async with db.execute(
                    '''
                    SELECT 
                        SUM(kills) as total_kills,
                        SUM(deaths) as total_deaths,
                        COUNT(DISTINCT session_id) as games,
                        MAX(session_date) as last_seen
                    FROM player_comprehensive_stats
                    WHERE player_guid = ?
                ''',
                    (guid,),
                ) as cursor:
                    stats = await cursor.fetchone()

                if not stats or stats[0] is None:
                    await ctx.send(
                        f"‚ùå GUID `{guid}` not found in database.\\n"
                        f"üí° Use `!link` (no args) to see available players."
                    )
                    return

                # Get aliases
                async with db.execute(
                    '''
                    SELECT player_name, last_seen, times_used
                    FROM player_aliases
                    WHERE player_guid = ?
                    ORDER BY last_seen DESC, times_used DESC
                    LIMIT 3
                ''',
                    (guid,),
                ) as cursor:
                    aliases = await cursor.fetchall()

                if aliases:
                    primary_name = aliases[0][0]
                    alias_str = ", ".join([a[0] for a in aliases[:3]])
                else:
                    # Fallback
                    async with db.execute(
                        '''
                        SELECT player_name 
                        FROM player_comprehensive_stats 
                        WHERE player_guid = ? 
                        ORDER BY session_date DESC 
                        LIMIT 1
                    ''',
                        (guid,),
                    ) as cursor:
                        name_row = await cursor.fetchone()
                        primary_name = name_row[0] if name_row else "Unknown"
                        alias_str = primary_name

                kills, deaths, games, last_seen = stats
                kd_ratio = kills / deaths if deaths > 0 else kills

                # Admin confirmation embed
                embed = discord.Embed(
                    title="üîó Admin Link Confirmation",
                    description=(
                        f"Link {target_user.mention} to **{primary_name}**?\\n\\n"
                        f"**Requested by:** {ctx.author.mention}"
                    ),
                    color=0xFF6B00,  # Orange for admin action
                )
                embed.add_field(
                    name="Target User",
                    value=f"{target_user.mention} ({target_user.name})",
                    inline=True,
                )
                embed.add_field(
                    name="GUID",
                    value=guid,
                    inline=True,
                )
                embed.add_field(
                    name="Known Names",
                    value=alias_str,
                    inline=False,
                )
                embed.add_field(
                    name="Stats",
                    value=(
                        f"**Kills:** {kills:,} | **Deaths:** {deaths:,}\\n"
                        f"**K/D:** {kd_ratio:.2f} | **Games:** {games:,}"
                    ),
                    inline=True,
                )
                embed.add_field(
                    name="Last Seen",
                    value=last_seen,
                    inline=True,
                )
                embed.set_footer(
                    text="React ‚úÖ (admin) to confirm or ‚ùå to cancel (60s)"
                )

                message = await ctx.send(embed=embed)
                await message.add_reaction('‚úÖ')
                await message.add_reaction('‚ùå')

                def check(reaction, user):
                    return (
                        user == ctx.author  # Only admin can confirm
                        and str(reaction.emoji) in ['‚úÖ', '‚ùå']
                        and reaction.message.id == message.id
                    )

                try:
                    reaction, user = await self.bot.wait_for(
                        'reaction_add', timeout=60.0, check=check
                    )

                    if str(reaction.emoji) == '‚úÖ':
                        # Confirmed - link it
                        await db.execute(
                            '''
                            INSERT OR REPLACE INTO player_links
                            (discord_id, discord_username, et_guid, et_name, 
                             linked_date, verified)
                            VALUES (?, ?, ?, ?, datetime('now'), 1)
                        ''',
                            (
                                target_discord_id,
                                str(target_user),
                                guid,
                                primary_name,
                            ),
                        )
                        await db.commit()

                        await message.clear_reactions()
                        
                        # Success message
                        success_embed = discord.Embed(
                            title="‚úÖ Admin Link Successful",
                            description=(
                                f"{target_user.mention} is now linked to "
                                f"**{primary_name}**"
                            ),
                            color=0x00FF00,
                        )
                        success_embed.add_field(
                            name="GUID",
                            value=guid,
                            inline=True,
                        )
                        success_embed.add_field(
                            name="Linked By",
                            value=ctx.author.mention,
                            inline=True,
                        )
                        success_embed.set_footer(
                            text=(
                                f"üí° {target_user.name} can now use "
                                f"!stats to see their stats"
                            )
                        )
                        
                        await ctx.send(embed=success_embed)
                        
                        # Log admin action
                        logger.info(
                            f"Admin link: {ctx.author} (ID: {ctx.author.id}) "
                            f"linked {target_user} (ID: {target_user.id}) "
                            f"to GUID {guid} ({primary_name})"
                        )
                        
                    else:
                        await message.clear_reactions()
                        await ctx.send("‚ùå Admin link cancelled.")

                except asyncio.TimeoutError:
                    await message.clear_reactions()
                    await ctx.send("‚è±Ô∏è Admin link confirmation timed out.")

        except Exception as e:
            logger.error(f"Error in admin link: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error during admin linking: {e}")

    @commands.command(name='unlink')
    async def unlink(self, ctx):
        """üîì Unlink your Discord account from your in-game profile"""
        try:
            discord_id = str(ctx.author.id)

            async with aiosqlite.connect(self.bot.db_path) as db:
                # Check if linked
                async with db.execute(
                    '''
                    SELECT player_name FROM player_links
                    WHERE discord_id = ?
                ''',
                    (discord_id,),
                ) as cursor:
                    existing = await cursor.fetchone()

                if not existing:
                    await ctx.send("‚ùå You don't have a linked account.")
                    return

                # Remove link
                await db.execute(
                    '''
                    UPDATE player_links
                    SET discord_id = NULL
                    WHERE discord_id = ?
                ''',
                    (discord_id,),
                )

                await db.commit()

            await ctx.send(f"‚úÖ Unlinked from **{existing[0]}**")

        except Exception as e:
            logger.error(f"Error in unlink command: {e}", exc_info=True)
            await ctx.send(f"‚ùå Error unlinking account: {e}")

    @commands.command(name='select')
    async def select_option(self, ctx, selection: int = None):
        """üî¢ Select an option from a link prompt (alternative to reactions)

        Usage: !select <1-3>
        
        Note: This works as an alternative to clicking reaction emojis.
        Must be used within 60 seconds of a !link command.
        """
        if selection is None:
            await ctx.send(
                "‚ùå Please specify a number!\\n"
                "Usage: `!select 1`, `!select 2`, or `!select 3`"
            )
            return

        if selection not in [1, 2, 3]:
            await ctx.send("‚ùå Please select 1, 2, or 3.")
            return

        await ctx.send(
            f"üí° You selected option **{selection}**!\\n\\n"
            f"**Note:** The `!select` command currently requires integration with the link workflow.\\n"
            f"For now, please use the reaction emojis (1Ô∏è‚É£/2Ô∏è‚É£/3Ô∏è‚É£) on the link message, "
            f"or use `!link <GUID>` to link directly.\\n\\n"
            f"**Tip:** To find your GUID, use `!link` (no arguments) and check the GUID field."
        )
        
        # TODO: Implement persistent selection state
        # This would require storing pending link requests per user
        # and checking if they have an active selection window


class UltimateETLegacyBot(commands.Bot):
    """üöÄ Ultimate consolidated ET:Legacy Discord bot with proper Cog structure"""

    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        super().__init__(command_prefix='!', intents=intents)

        # üìä Database Configuration - Try multiple locations
        import os

        bot_dir = os.path.dirname(os.path.abspath(__file__))
        parent_dir = os.path.dirname(bot_dir)
        
        # ‚úÖ Try multiple database locations
        possible_paths = [
            os.path.join(parent_dir, 'etlegacy_production.db'),  # Project root
            os.path.join(bot_dir, 'etlegacy_production.db'),     # Bot directory
            'etlegacy_production.db',                             # Current dir
        ]
        
        self.db_path = None
        for path in possible_paths:
            if os.path.exists(path):
                self.db_path = path
                logger.info(f"‚úÖ Database found: {path}")
                break
        
        if not self.db_path:
            error_msg = (
                f"‚ùå DATABASE NOT FOUND!\n"
                f"Tried: {possible_paths}\n"
                f"Run: python create_unified_database.py"
            )
            logger.error(error_msg)
            raise FileNotFoundError(error_msg)

        # üéÆ Bot State
        self.current_session = None
        self.monitoring = False
        self.processed_files = set()
        self.auto_link_enabled = True
        self.gather_queue = {"3v3": [], "6v6": []}


        # ü§ñ Automation System Flags (OFF by default for dev/testing)
        self.automation_enabled = os.getenv('AUTOMATION_ENABLED', 'false').lower() == 'true'
        self.ssh_enabled = os.getenv('SSH_ENABLED', 'false').lower() == 'true'
        
        if self.automation_enabled:
            logger.info("‚úÖ Automation system ENABLED")
        else:
            logger.warning("‚ö†Ô∏è Automation system DISABLED (set AUTOMATION_ENABLED=true to enable)")
        # ÔøΩÔ∏è Voice Channel Session Detection
        self.session_active = False
        self.session_start_time = None
        self.session_participants = set()  # Discord user IDs
        self.session_end_timer = None  # For 5-minute buffer
        self.gaming_sessions_db_id = None  # Link to gaming_sessions table
        
        # Load gaming voice channel IDs from .env
        gaming_channels_str = os.getenv('GAMING_VOICE_CHANNELS', '')
        self.gaming_voice_channels = [
            int(ch.strip()) for ch in gaming_channels_str.split(',') if ch.strip()
        ] if gaming_channels_str else []
        
        # Session thresholds
        self.session_start_threshold = int(os.getenv('SESSION_START_THRESHOLD', '6'))
        self.session_end_threshold = int(os.getenv('SESSION_END_THRESHOLD', '2'))
        self.session_end_delay = int(os.getenv('SESSION_END_DELAY', '300'))  # 5 minutes
        
        if self.gaming_voice_channels:
            logger.info(f"üéôÔ∏è Voice monitoring enabled for channels: {self.gaming_voice_channels}")
            logger.info(f"üìä Thresholds: {self.session_start_threshold}+ to start, <{self.session_end_threshold} for {self.session_end_delay}s to end")
        else:
            logger.warning("‚ö†Ô∏è No gaming voice channels configured - voice detection disabled")

        # ÔøΩüèÜ Awards and achievements tracking
        self.awards_cache = {}
        self.mvp_cache = {}

        # üìà Performance tracking
        self.command_stats = {}
        self.error_count = 0

    async def validate_database_schema(self):
        """
        ‚úÖ CRITICAL: Validate database has correct unified schema (53 columns)
        Prevents silent failures if wrong schema is used
        """
        try:
            async with aiosqlite.connect(self.db_path) as db:
                # Check player_comprehensive_stats has 53 columns
                cursor = await db.execute(
                    "PRAGMA table_info(player_comprehensive_stats)"
                )
                columns = await cursor.fetchall()
                
                expected_columns = 53
                actual_columns = len(columns)
                
                if actual_columns != expected_columns:
                    error_msg = (
                        f"‚ùå DATABASE SCHEMA MISMATCH!\n"
                        f"Expected: {expected_columns} columns (UNIFIED)\n"
                        f"Found: {actual_columns} columns\n\n"
                        f"Schema: {'SPLIT (deprecated)' if actual_columns == 35 else 'UNKNOWN'}\n\n"
                        f"Solution:\n"
                        f"1. Backup: cp etlegacy_production.db backup.db\n"
                        f"2. Create: python create_unified_database.py\n"
                        f"3. Import: python tools/simple_bulk_import.py local_stats/*.txt\n"
                    )
                    
                    logger.error(error_msg)
                    raise RuntimeError(error_msg)
                
                # Verify objective stats columns exist
                column_names = [col[1] for col in columns]
                required_stats = [
                    'kill_assists', 'dynamites_planted', 'times_revived',
                    'revives_given', 'most_useful_kills', 'useless_kills'
                ]
                
                missing = [col for col in required_stats if col not in column_names]
                if missing:
                    logger.error(f"‚ùå MISSING COLUMNS: {missing}")
                    raise RuntimeError(f"Missing objective stats: {missing}")
                
                logger.info(f"‚úÖ Schema validated: {actual_columns} columns (UNIFIED)")
                
        except Exception as e:
            logger.error(f"‚ùå Schema validation failed: {e}")
            raise

    def safe_divide(self, numerator, denominator, default=0.0):
        """‚úÖ NULL-safe division"""
        try:
            if numerator is None or denominator is None or denominator == 0:
                return default
            return numerator / denominator
        except (TypeError, ZeroDivisionError):
            return default

    def safe_percentage(self, part, total, default=0.0):
        """‚úÖ NULL-safe percentage (returns 0-100)"""
        result = self.safe_divide(part, total, default)
        return result * 100 if result != default else default

    def safe_dpm(self, damage, time_seconds, default=0.0):
        """‚úÖ NULL-safe DPM calculation: (damage * 60) / time_seconds"""
        try:
            if damage is None or time_seconds is None or time_seconds == 0:
                return default
            return (damage * 60) / time_seconds
        except (TypeError, ZeroDivisionError):
            return default

    async def send_with_delay(self, ctx, *args, delay=0.5, **kwargs):
        """‚úÖ Send message with rate limit delay"""
        await ctx.send(*args, **kwargs)
        await asyncio.sleep(delay)

    async def get_hardcoded_teams(self, db, session_date):
        """üéØ Get hardcoded teams from session_teams table if available
        
        Returns dict with team info or None if not available:
        {
            'Team A': {
                'guids': ['GUID1', 'GUID2', ...],
                'names': ['Name1', 'Name2', ...],
                'maps': ['map1', 'map2', ...]
            },
            'Team B': { ... }
        }
        """
        try:
            import json
            
            # Check if session_teams table exists
            async with db.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name='session_teams'"
            ) as cursor:
                if not await cursor.fetchone():
                    return None
            
            # Get all teams for this session date
            async with db.execute(
                '''
                SELECT team_name, player_guids, player_names, map_name
                FROM session_teams
                WHERE session_start_date LIKE ?
                ORDER BY team_name
                ''',
                (f"{session_date}%",)
            ) as cursor:
                rows = await cursor.fetchall()
            
            if not rows:
                return None
            
            # Organize by team name
            teams = {}
            for team_name, guids_json, names_json, map_name in rows:
                if team_name not in teams:
                    teams[team_name] = {
                        'guids': set(json.loads(guids_json)),
                        'names': set(json.loads(names_json)),
                        'maps': []
                    }
                teams[team_name]['maps'].append(map_name)
            
            # Convert sets to sorted lists for consistency
            for team_name in teams:
                teams[team_name]['guids'] = sorted(list(teams[team_name]['guids']))
                teams[team_name]['names'] = sorted(list(teams[team_name]['names']))
            
            logger.info(f"‚úÖ Found hardcoded teams for {session_date}: {list(teams.keys())}")
            return teams
            
        except Exception as e:
            logger.error(f"Error getting hardcoded teams: {e}", exc_info=True)
            return None

    async def setup_hook(self):
        """üîß Initialize all bot components"""
        logger.info("üöÄ Initializing Ultimate ET:Legacy Bot...")

        # ‚úÖ CRITICAL: Validate schema FIRST
        await self.validate_database_schema()

        # Add the commands cog
        await self.add_cog(ETLegacyCommands(self))

        # Initialize database
        await self.initialize_database()

        # Start background tasks
        self.endstats_monitor.start()
        self.cache_refresher.start()

        logger.info("‚úÖ Ultimate Bot initialization complete!")
        logger.info(f"üìã Commands available: {[cmd.name for cmd in self.commands]}")

    async def initialize_database(self):
        """üìä Verify database tables exist (created by recreate_database.py)"""
        async with aiosqlite.connect(self.db_path) as db:
            # Verify critical tables exist
            required_tables = [
                'sessions',
                'player_comprehensive_stats',
                'weapon_comprehensive_stats',
                'player_links',
            ]

            cursor = await db.execute(
                """
                SELECT name FROM sqlite_master
                WHERE type='table' AND name IN (?, ?, ?, ?)
            """,
                tuple(required_tables),
            )

            existing_tables = [row[0] for row in await cursor.fetchall()]

            missing_tables = set(required_tables) - set(existing_tables)

            if missing_tables:
                logger.error(f"‚ùå Missing required tables: {missing_tables}")
                logger.error("   Run: python recreate_database.py")
                logger.error("   Then: python tools/simple_bulk_import.py")
                raise Exception(f"Database missing required tables: {missing_tables}")

            logger.info(f"‚úÖ Database verified - all {len(required_tables)} required tables exist")

    # üéôÔ∏è VOICE CHANNEL SESSION DETECTION

    async def on_voice_state_update(self, member, before, after):
        """üéôÔ∏è Detect gaming sessions based on voice channel activity"""
        if not self.automation_enabled:
            return  # Automation disabled
        
        if not self.gaming_voice_channels:
            return  # Voice detection disabled
        
        try:
            # Count players in gaming voice channels
            total_players = 0
            current_participants = set()
            
            for channel_id in self.gaming_voice_channels:
                channel = self.get_channel(channel_id)
                if channel and isinstance(channel, discord.VoiceChannel):
                    total_players += len(channel.members)
                    current_participants.update([m.id for m in channel.members])
            
            logger.debug(f"üéôÔ∏è Voice update: {total_players} players in gaming channels")
            
            # Session Start Detection
            if total_players >= self.session_start_threshold and not self.session_active:
                await self._start_gaming_session(current_participants)
            
            # Session End Detection
            elif total_players < self.session_end_threshold and self.session_active:
                # Cancel existing timer if any
                if self.session_end_timer:
                    self.session_end_timer.cancel()
                
                # Start 5-minute countdown
                self.session_end_timer = asyncio.create_task(
                    self._delayed_session_end(current_participants)
                )
            
            # Update participants if session active
            elif self.session_active:
                # Add new participants
                new_participants = current_participants - self.session_participants
                if new_participants:
                    self.session_participants.update(new_participants)
                    logger.info(f"üë• New participants joined: {len(new_participants)}")
                
                # Cancel end timer if people came back
                if self.session_end_timer and total_players >= self.session_end_threshold:
                    self.session_end_timer.cancel()
                    self.session_end_timer = None
                    logger.info(f"‚è∞ Session end cancelled - players returned ({total_players} in voice)")
        
        except Exception as e:
            logger.error(f"Voice state update error: {e}", exc_info=True)

    async def _start_gaming_session(self, participants):
        """üéÆ Start a gaming session when 6+ players in voice"""
        try:
            self.session_active = True
            self.session_start_time = discord.utils.utcnow()
            self.session_participants = participants.copy()
            
            # Enable monitoring
            self.monitoring = True
            
            # Create database entry
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute('''
                    INSERT INTO gaming_sessions (
                        start_time, participant_count, participants, status
                    ) VALUES (?, ?, ?, 'active')
                ''', (
                    self.session_start_time.isoformat(),
                    len(participants),
                    ','.join(str(uid) for uid in participants)
                ))
                self.gaming_sessions_db_id = cursor.lastrowid
                await db.commit()
            
            logger.info(f"üéÆ GAMING SESSION STARTED! {len(participants)} players detected")
            logger.info(f"üìä Session ID: {self.gaming_sessions_db_id}")
            logger.info(f"üîÑ Monitoring enabled")
            
            # Post to Discord if stats channel configured
            stats_channel_id = os.getenv('STATS_CHANNEL_ID')
            if stats_channel_id:
                channel = self.get_channel(int(stats_channel_id))
                if channel:
                    embed = discord.Embed(
                        title="üéÆ Gaming Session Started!",
                        description=f"{len(participants)} players detected in voice channels",
                        color=0x00FF00,
                        timestamp=self.session_start_time
                    )
                    embed.add_field(
                        name="Status",
                        value="Monitoring enabled automatically",
                        inline=False
                    )
                    embed.set_footer(text="Good luck and have fun! ÔøΩ")
                    await channel.send(embed=embed)
        
        except Exception as e:
            logger.error(f"Error starting gaming session: {e}", exc_info=True)

    async def _delayed_session_end(self, last_participants):
        """‚è∞ Wait 5 minutes before ending session (allows bathroom breaks)"""
        try:
            logger.info(f"‚è∞ Session end timer started - waiting {self.session_end_delay}s...")
            await asyncio.sleep(self.session_end_delay)
            
            # Re-check player count after delay
            total_players = 0
            for channel_id in self.gaming_voice_channels:
                channel = self.get_channel(channel_id)
                if channel and isinstance(channel, discord.VoiceChannel):
                    total_players += len(channel.members)
            
            if total_players >= self.session_end_threshold:
                logger.info(f"‚è∞ Session end cancelled - players returned ({total_players} in voice)")
                return
            
            # Still empty after delay - end session
            await self._end_gaming_session()
        
        except asyncio.CancelledError:
            logger.debug("‚è∞ Session end timer cancelled")
        except Exception as e:
            logger.error(f"Error in delayed session end: {e}", exc_info=True)

    async def _end_gaming_session(self):
        """üèÅ End gaming session and post summary"""
        try:
            if not self.session_active:
                return
            
            end_time = discord.utils.utcnow()
            duration = end_time - self.session_start_time
            
            # Update database
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute('''
                    UPDATE gaming_sessions
                    SET end_time = ?, duration_seconds = ?, status = 'ended'
                    WHERE session_id = ?
                ''', (
                    end_time.isoformat(),
                    int(duration.total_seconds()),
                    self.gaming_sessions_db_id
                ))
                await db.commit()
            
            # Disable monitoring
            self.monitoring = False
            
            logger.info(f"üèÅ GAMING SESSION ENDED!")
            logger.info(f"‚è±Ô∏è Duration: {duration}")
            logger.info(f"üë• Participants: {len(self.session_participants)}")
            logger.info(f"ÔøΩüîÑ Monitoring disabled")
            
            # Post session summary (will be implemented in next todo)
            stats_channel_id = os.getenv('STATS_CHANNEL_ID')
            if stats_channel_id:
                channel = self.get_channel(int(stats_channel_id))
                if channel:
                    # TODO: Post comprehensive session summary
                    embed = discord.Embed(
                        title="üèÅ Gaming Session Complete!",
                        description=f"Duration: {self._format_duration(duration)}",
                        color=0xFFD700,
                        timestamp=end_time
                    )
                    embed.add_field(
                        name="üë• Participants",
                        value=f"{len(self.session_participants)} players",
                        inline=True
                    )
                    embed.set_footer(text="Thanks for playing! GG! üéÆ")
                    await channel.send(embed=embed)
            
            # Reset session state
            self.session_active = False
            self.session_start_time = None
            self.session_participants = set()
            self.session_end_timer = None
            self.gaming_sessions_db_id = None
        
        except Exception as e:
            logger.error(f"Error ending gaming session: {e}", exc_info=True)

    def _format_duration(self, duration):
        """Format timedelta as human-readable string"""
        total_seconds = int(duration.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        
        if hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"

    # üîÑ BACKGROUND TASKS

    @tasks.loop(seconds=30)
    async def endstats_monitor(self):
        """üîÑ Monitor for new EndStats files"""
        if not self.monitoring:
            return

        try:
            # SSH connection logic here (next todo)
            pass

        except Exception as e:
            logger.error(f"EndStats monitoring error: {e}")

    @tasks.loop(minutes=10)
    async def cache_refresher(self):
        """üîÑ Refresh performance caches"""
        try:
            # Refresh awards and MVP caches
            self.awards_cache.clear()
            self.mvp_cache.clear()

        except Exception as e:
            logger.error(f"Cache refresh error: {e}")

    async def on_ready(self):
        """‚úÖ Bot startup message"""
        logger.info(f'üöÄ Ultimate ET:Legacy Bot logged in as {self.user}')
        logger.info(f'üìä Connected to database: {self.db_path}')
        logger.info(f'üéÆ Bot ready with {len(list(self.commands))} commands!')

        # Clear any old slash commands to avoid confusion
        try:
            self.tree.clear_commands(guild=None)
            await self.tree.sync()
            logger.info("üßπ Cleared old slash commands")
        except Exception as e:
            logger.warning(f"Could not clear slash commands: {e}")

    async def on_command_error(self, ctx, error):
        """üö® Handle command errors"""
        self.error_count += 1

        if isinstance(error, commands.CommandNotFound):
            await ctx.send("‚ùå Command not found. Use `!help_command` for available commands.")
        elif isinstance(error, commands.MissingRequiredArgument):
            await ctx.send(f"‚ùå Missing argument: {error.param}. Use `!help_command` for usage.")
        else:
            logger.error(f"Command error: {error}")
            await ctx.send(f"‚ùå An error occurred: {error}")


# üöÄ BOT STARTUP
def main():
    """üöÄ Start the Ultimate ET:Legacy Discord Bot"""

    # Get Discord token
    token = os.getenv('DISCORD_BOT_TOKEN')
    if not token:
        logger.error("‚ùå DISCORD_BOT_TOKEN not found in environment variables!")
        logger.info("Please set your Discord bot token in the .env file")
        return

    # Create and run bot
    bot = UltimateETLegacyBot()

    try:
        logger.info("üöÄ Starting Ultimate ET:Legacy Bot...")
        bot.run(token)
    except discord.LoginFailure:
        logger.error("‚ùå Invalid Discord token!")
    except Exception as e:
        logger.error(f"‚ùå Bot startup failed: {e}")


if __name__ == "__main__":
    main()
