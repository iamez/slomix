# Evidence: WS1B-003 Ingestion Dedupe and Idempotency Policy
Date: 2026-02-13  
Workstream: WS1B (Unified Ingestion Contract)  
Task: `WS1B-003`  
Status: `done`

## Objective
Define deterministic behavior when multiple sources emit the same round.

## Dedupe Order
1. Compute round fingerprint using WS1B precedence.
2. Check source-specific hard unique keys.
3. If both exist, update existing row/event (idempotent upsert), do not append duplicate.

## Source-Specific Rules
`filename_trigger` (stats file import):
1. Unique identity: `round_date + round_time + map_name + round_number`
2. Behavior on replay:
   - if round already exists, skip duplicate insert
   - allow deterministic metadata update only when explicitly expected

`stats_ready` / `gametime_fallback` (`lua_round_teams`):
1. Unique identity: `match_id + round_number`
2. Behavior on replay:
   - upsert overwrite of mutable Lua fields
   - keep existing `round_id` when new payload does not provide one
   - update `captured_at`

`lua_spawn_stats`:
1. Unique identity: `match_id + round_number + player_guid`
2. Behavior on replay:
   - upsert per-player spawn/death timing
   - no duplicate rows for same player round tuple

`proximity_file`:
1. Unique identity: canonical round-start key where available
2. Behavior on replay:
   - importer must be idempotent; second pass produces no count growth

## Cross-Source Merge Policy
If the same fingerprint arrives from multiple sources:
1. Keep all source events for auditability.
2. Produce one canonical linked round identity.
3. Prefer field authority by domain:
   - timing/winner/end_reason: Lua (`stats_ready`/`gametime_fallback`)
   - player stat totals: stats file
   - engagement micro-events: proximity

## Failure Handling
1. On unique-violation of non-canonical legacy constraints: classify as schema drift, not new data.
2. On parse success but link miss: retain event with `link_status=unlinked` and reason code.
3. Never drop raw event silently; always log/update state.

## Acceptance
1. Replaying the same source artifact twice does not grow row counts unexpectedly.
2. Replaying via a second source updates/links existing identity rather than creating parallel round records.
