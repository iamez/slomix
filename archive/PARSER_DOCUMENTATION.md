# üìù ET:Legacy Stats Parser - Complete Documentation

**Version:** 3.0  
**Last Updated:** October 3, 2025  
**File:** `bot/community_stats_parser.py`  
**Status:** Production Ready ‚úÖ

---

## üìã Table of Contents

1. [Overview](#overview)
2. [Parser Architecture](#parser-architecture)
3. [File Format](#file-format)
4. [Parsing Process](#parsing-process)
5. [Round 2 Differential](#round-2-differential)
6. [Field Mapping](#field-mapping)
7. [Usage Examples](#usage-examples)
8. [Error Handling](#error-handling)

---

## üéØ Overview

The C0RNP0RN3 Stats Parser (`community_stats_parser.py`) is responsible for reading stats files generated by the c0rnp0rn3.lua script and converting them into structured Python dictionaries for database storage.

### Key Responsibilities

- ‚úÖ Parse header metadata (map, round, time, teams)
- ‚úÖ Parse player lines (all 37+ fields)
- ‚úÖ Parse weapon stats (kills, hits, shots, accuracy per weapon)
- ‚úÖ Calculate DPM (Damage Per Minute)
- ‚úÖ Handle Round 2 differential (subtract Round 1 from Round 2)
- ‚úÖ Convert time to seconds (INTEGER storage)
- ‚úÖ Validate and clean data

---

## üèóÔ∏è Parser Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            C0RNP0RN3StatsParser Class                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                     ‚îÇ                     ‚îÇ
        ‚ñº                     ‚ñº                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ parse_stats_  ‚îÇ    ‚îÇ parse_header  ‚îÇ    ‚îÇ parse_player_ ‚îÇ
‚îÇ   file()      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ    ()         ‚îÇ    ‚îÇ   line()      ‚îÇ
‚îÇ               ‚îÇ    ‚îÇ               ‚îÇ    ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                                         ‚îÇ
        ‚îÇ                                         ‚îÇ
        ‚ñº                                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ calculate_    ‚îÇ                        ‚îÇ parse_weapon_ ‚îÇ
‚îÇ  r2_diff()    ‚îÇ                        ‚îÇ   stats()     ‚îÇ
‚îÇ               ‚îÇ                        ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Main Method: `parse_stats_file()`

**Input:** File path to .txt stats file  
**Output:** Python dictionary with structured data

```python
def parse_stats_file(self, file_path: str) -> dict:
    """
    Parse a c0rnp0rn3 stats file
    
    Args:
        file_path: Path to stats .txt file
        
    Returns:
        {
            'success': True/False,
            'map_name': 'etl_adlernest',
            'round_num': 1,
            'actual_time': '11:26',
            'actual_time_seconds': 686,
            'players': [
                {
                    'guid': '12345678',
                    'name': 'vid',
                    'team': 2,
                    'kills': 45,
                    'deaths': 32,
                    'damage_given': 4567,
                    'time_played_seconds': 686,
                    'time_display': '11:26',
                    'dpm': 344.94,
                    'objective_stats': {...},
                    'weapons': [...]
                },
                ...
            ]
        }
    """
```

---

## üìÑ File Format

### File Naming Convention

```
YYYY-MM-DD-HHMMSS-mapname-round-N.txt

Examples:
2025-10-02-211808-etl_adlernest-round-1.txt
2025-10-02-212249-etl_adlernest-round-2.txt
2025-10-02-213333-supply-round-1.txt
```

### Header Format

```
servername\mapname\config\round\defenderteam\winnerteam\timelimit\nextttimelimit\actualtime
```

**Example:**
```
ETL Community Server\etl_adlernest\3on3\1\2\2\10:00\10:00\686
```

**Fields:**
- `servername` - Server hostname
- `mapname` - Map name (e.g., "etl_adlernest", "supply")
- `config` - Server config (e.g., "3on3", "6on6")
- `round` - Round number (1 or 2)
- `defenderteam` - Defending team (1=Axis, 2=Allies)
- `winnerteam` - Winning team (1=Axis, 2=Allies, 0=Draw)
- `timelimit` - Map time limit (MM:SS)
- `nextttimelimit` - Next round time limit (MM:SS)
- `actualtime` - **SECONDS** (not MM:SS in header)

### Player Line Format

```
GUID\PlayerName\Round\Team\WeaponMask [weapon_stats] \t [37 objective fields]
```

**Example:**
```
12345678\vid\1\2\134217727 312 845 25 3 45 ... \t 4567 2134 0 0 12 1 2 0 686 45230 5 3 10 8 45 ...
```

**Structure:**
1. `GUID` - 8-character hex player ID
2. `PlayerName` - Player nickname
3. `Round` - Round number (1 or 2)
4. `Team` - Team (1=Axis, 2=Allies)
5. `WeaponMask` - Bitmask indicating which weapons were used
6. `[weapon_stats]` - 28 weapons √ó 5 fields each (hits, shots, kills, deaths, headshots)
7. `\t` - Tab separator
8. `[objective_fields]` - 37 objective/support stat fields

---

## ‚öôÔ∏è Parsing Process

### Step 1: Parse Header

```python
def parse_header(self, header_line: str) -> dict:
    """Parse header line to extract session metadata"""
    parts = header_line.strip().split('\\')
    
    return {
        'server_name': parts[0],
        'map_name': parts[1],
        'config': parts[2],
        'round_num': int(parts[3]),
        'defender_team': int(parts[4]),
        'winner_team': int(parts[5]),
        'time_limit': parts[6],        # MM:SS
        'next_time_limit': parts[7],   # MM:SS
        'actual_time_seconds': int(float(parts[8]))  # SECONDS from Lua
    }
```

**Time Conversion:**
```python
# Convert seconds to MM:SS display
seconds = 686
minutes = seconds // 60  # 11
secs = seconds % 60      # 26
display = f"{minutes}:{secs:02d}"  # "11:26"
```

### Step 2: Parse Player Line

```python
def parse_player_line(self, line: str) -> dict:
    """Parse a single player stats line"""
    # Split by backslash for identity part
    parts = line.split('\\')
    guid = parts[0]
    name = parts[1]
    round_num = int(parts[2])
    team = int(parts[3])
    
    # Split by tab for stats
    stats_part = parts[4]
    if '\t' in stats_part:
        weapon_part, objective_part = stats_part.split('\t', 1)
    else:
        weapon_part = stats_part
        objective_part = ""
    
    # Parse weapon stats
    weapons = self.parse_weapon_stats(weapon_part)
    
    # Parse objective stats (37 fields)
    obj_stats = self.parse_objective_stats(objective_part)
    
    return {
        'guid': guid,
        'name': name,
        'round': round_num,
        'team': team,
        'weapons': weapons,
        'objective_stats': obj_stats,
        ...
    }
```

### Step 3: Parse Weapon Stats

**Weapon data format:** `[weapon_mask] hits shots kills deaths hs hits shots kills deaths hs ...`

```python
def parse_weapon_stats(self, weapon_string: str) -> list:
    """Parse weapon stats for all 28 weapons"""
    fields = weapon_string.strip().split()
    weapon_mask = int(fields[0])
    weapon_data = fields[1:]
    
    weapons = []
    weapon_names = [
        'WS_KNIFE', 'WS_KNIFE_KBAR', 'WS_LUGER', 'WS_COLT',
        'WS_MP40', 'WS_THOMPSON', 'WS_STEN', 'WS_FG42',
        # ... all 28 weapons
    ]
    
    # Each weapon has 5 fields: hits, shots, kills, deaths, headshots
    for i in range(28):
        offset = i * 5
        if offset + 5 <= len(weapon_data):
            hits = int(weapon_data[offset])
            shots = int(weapon_data[offset + 1])
            kills = int(weapon_data[offset + 2])
            deaths = int(weapon_data[offset + 3])
            headshots = int(weapon_data[offset + 4])
            
            # Only store if weapon was actually used
            if shots > 0 or kills > 0 or deaths > 0:
                accuracy = (hits / shots * 100) if shots > 0 else 0
                
                weapons.append({
                    'weapon_id': i,
                    'weapon_name': weapon_names[i],
                    'hits': hits,
                    'shots': shots,
                    'kills': kills,
                    'deaths': deaths,
                    'headshots': headshots,
                    'accuracy': round(accuracy, 2)
                })
    
    return weapons
```

### Step 4: Parse Objective Stats

**37 Fields after tab separator:**

```python
def parse_objective_stats(self, objective_string: str) -> dict:
    """Parse the 37 objective/support stat fields"""
    if not objective_string:
        return {}
    
    fields = objective_string.strip().split()
    
    # Field mapping (c0rnp0rn3 order)
    return {
        'damage_given': int(fields[0]) if len(fields) > 0 else 0,
        'damage_received': int(fields[1]) if len(fields) > 1 else 0,
        'team_damage_given': int(fields[2]) if len(fields) > 2 else 0,
        'team_damage_received': int(fields[3]) if len(fields) > 3 else 0,
        'gibs': int(fields[4]) if len(fields) > 4 else 0,
        'self_kills': int(fields[5]) if len(fields) > 5 else 0,
        'team_kills': int(fields[6]) if len(fields) > 6 else 0,
        'team_gibs': int(fields[7]) if len(fields) > 7 else 0,
        'time_played_percent': float(fields[8]) if len(fields) > 8 else 0,
        'xp': int(fields[9]) if len(fields) > 9 else 0,
        'killing_spree': int(fields[10]) if len(fields) > 10 else 0,
        'death_spree': int(fields[11]) if len(fields) > 11 else 0,
        'dpm_lua': float(fields[12]) if len(fields) > 12 else 0,  # From Lua
        'kill_assists': int(fields[13]) if len(fields) > 13 else 0,
        'kill_steals': int(fields[14]) if len(fields) > 14 else 0,
        'headshot_kills': int(fields[15]) if len(fields) > 15 else 0,
        'objectives_stolen': int(fields[16]) if len(fields) > 16 else 0,
        'objectives_returned': int(fields[17]) if len(fields) > 17 else 0,
        'dynamites_planted': int(fields[18]) if len(fields) > 18 else 0,
        'dynamites_defused': int(fields[19]) if len(fields) > 19 else 0,
        'times_revived': int(fields[20]) if len(fields) > 20 else 0,
        'bullets_fired': int(fields[21]) if len(fields) > 21 else 0,
        # Field 22: DPM (recalculated, we use field 12)
        'time_minutes_lua': float(fields[23]) if len(fields) > 23 else 0,
        'tank_meatshield': float(fields[24]) if len(fields) > 24 else 0,
        'time_dead_ratio': float(fields[25]) if len(fields) > 25 else 0,
        # Field 26: unused
        'kd_ratio_lua': float(fields[27]) if len(fields) > 27 else 0,
        'most_useful_kills': int(fields[28]) if len(fields) > 28 else 0,
        'denied_playtime': int(fields[29]) if len(fields) > 29 else 0,  # seconds
        'double_kills': int(fields[30]) if len(fields) > 30 else 0,
        'triple_kills': int(fields[31]) if len(fields) > 31 else 0,
        'quad_kills': int(fields[32]) if len(fields) > 32 else 0,
        'multi_kills': int(fields[33]) if len(fields) > 33 else 0,  # 5x
        'mega_kills': int(fields[34]) if len(fields) > 34 else 0,   # 6x
        'useless_kills': int(fields[35]) if len(fields) > 35 else 0,
        'full_selfkills': int(fields[36]) if len(fields) > 36 else 0,
        'repairs_constructions': int(fields[37]) if len(fields) > 37 else 0,
        'revives_given': int(fields[38]) if len(fields) > 38 else 0
    }
```

### Step 5: Calculate DPM and Time

**DPM Calculation (seconds-based):**

```python
def calculate_dpm(damage: int, time_seconds: int) -> float:
    """
    Calculate Damage Per Minute
    
    Formula: DPM = (damage * 60) / time_seconds
    
    Args:
        damage: Total damage dealt
        time_seconds: Time played in seconds
        
    Returns:
        Damage per minute (float)
    """
    if time_seconds <= 0:
        return 0.0
    
    return round((damage * 60) / time_seconds, 2)
```

**Example:**
```python
damage = 1328
time_seconds = 231  # 3 minutes 51 seconds

dpm = (1328 * 60) / 231
dpm = 79680 / 231
dpm = 344.94
```

**Time Conversion:**
```python
# From header: actual_time_seconds = 686
time_played_seconds = 686  # ‚≠ê INTEGER storage

# Create display format
minutes = time_played_seconds // 60  # 11
seconds = time_played_seconds % 60   # 26
time_display = f"{minutes}:{seconds:02d}"  # "11:26"

# DEPRECATED: time_played_minutes (backward compat only)
time_played_minutes = time_played_seconds / 60.0  # 11.433333
```

---

## üîÑ Round 2 Differential

### Problem

In Round 2, the Lua script outputs **CUMULATIVE** stats (Round 1 + Round 2 combined). We need to calculate Round 2-only stats by subtracting Round 1.

### Detection

```python
def is_round_2_file(filename: str) -> bool:
    """Check if file is Round 2"""
    return '-round-2.txt' in filename
```

### Find Corresponding Round 1

```python
def find_round_1_file(round_2_path: str) -> str:
    """
    Find corresponding Round 1 file
    
    Example:
        Input:  2025-10-02-212249-etl_adlernest-round-2.txt
        Search: 2025-10-02-*-etl_adlernest-round-1.txt
        Find:   2025-10-02-211808-etl_adlernest-round-1.txt
    """
    directory = os.path.dirname(round_2_path)
    filename = os.path.basename(round_2_path)
    
    # Extract date and map from filename
    parts = filename.split('-')
    date = '-'.join(parts[0:3])  # YYYY-MM-DD
    map_name = '-'.join(parts[4:-2])  # etl_adlernest
    
    # Search for Round 1 with same date and map
    pattern = f"{date}-*-{map_name}-round-1.txt"
    search_path = os.path.join(directory, pattern)
    
    matches = glob.glob(search_path)
    if matches:
        # Return most recent (closest timestamp)
        return sorted(matches)[-1]
    
    return None
```

### Calculate Differential

```python
def calculate_r2_differential(self, r2_result: dict, r1_result: dict) -> dict:
    """
    Calculate Round 2-only stats by subtracting Round 1
    
    Args:
        r2_result: Parsed Round 2 data (cumulative)
        r1_result: Parsed Round 1 data
        
    Returns:
        Round 2-only stats (differential)
    """
    differential_players = []
    
    for r2_player in r2_result['players']:
        # Find matching player in Round 1 by GUID
        r1_player = next(
            (p for p in r1_result['players'] if p['guid'] == r2_player['guid']),
            None
        )
        
        if not r1_player:
            # Player didn't play Round 1, use Round 2 as-is
            differential_players.append(r2_player)
            continue
        
        # Subtract Round 1 stats from Round 2
        diff_player = r2_player.copy()
        
        # Subtract combat stats
        diff_player['kills'] = max(0, r2_player['kills'] - r1_player['kills'])
        diff_player['deaths'] = max(0, r2_player['deaths'] - r1_player['deaths'])
        diff_player['damage_given'] = max(0, 
            r2_player.get('damage_given', 0) - r1_player.get('damage_given', 0))
        
        # Subtract objective stats
        r2_obj = r2_player.get('objective_stats', {})
        r1_obj = r1_player.get('objective_stats', {})
        diff_obj = {}
        
        for key in r2_obj:
            if key in ['time_played_seconds', 'xp', 'damage_given']:
                # Subtractable fields
                diff_obj[key] = max(0, r2_obj[key] - r1_obj.get(key, 0))
            else:
                # Non-subtractable (use Round 2 value)
                diff_obj[key] = r2_obj[key]
        
        diff_player['objective_stats'] = diff_obj
        
        # Recalculate DPM with new damage and time
        time_seconds = diff_obj.get('time_played_seconds', 0)
        if time_seconds > 0:
            diff_player['dpm'] = (diff_player['damage_given'] * 60) / time_seconds
        else:
            diff_player['dpm'] = 0
        
        differential_players.append(diff_player)
    
    r2_result['players'] = differential_players
    return r2_result
```

**Example:**

```
Round 1 (vid):
  kills: 45, damage: 4567, time: 686s

Round 2 CUMULATIVE (vid):
  kills: 88, damage: 9234, time: 1301s

Round 2 DIFFERENTIAL (calculated):
  kills: 88 - 45 = 43
  damage: 9234 - 4567 = 4667
  time: 1301 - 686 = 615s
  DPM: (4667 * 60) / 615 = 455.02
```

---

## üìä Field Mapping Reference

### Complete Field Map (37 fields)

| Index | Lua Field | Database Column | Type | Description |
|-------|-----------|-----------------|------|-------------|
| 0 | damage_given | damage_given | INT | Total damage dealt |
| 1 | damage_received | damage_received | INT | Total damage received |
| 2 | team_damage_given | team_damage_given | INT | Friendly fire damage |
| 3 | team_damage_received | team_damage_received | INT | FF damage received |
| 4 | gibs | gibs | INT | Gib kills |
| 5 | selfkills | self_kills | INT | Suicide deaths |
| 6 | teamkills | team_kills | INT | Team kills |
| 7 | teamgibs | team_gibs | INT | Team gibs |
| 8 | timePlayed | (percent - ignored) | REAL | Time % (not used) |
| 9 | xp | xp | INT | Experience points |
| 10 | killing_spree | killing_spree_best | INT | Best killing spree |
| 11 | death_spree | death_spree_worst | INT | Worst death spree |
| 12 | topshots[12] | dpm (Lua calc) | REAL | DPM from Lua |
| 13 | topshots[3] | kill_assists | INT | Assisted kills |
| 14 | topshots[4] | kill_steals | INT | Stolen kills |
| 15 | topshots[5] | headshot_kills | INT | Kills by headshot |
| 16 | topshots[6] | objectives_stolen | INT | Objectives stolen |
| 17 | topshots[7] | objectives_returned | INT | Objectives returned |
| 18 | topshots[8] | dynamites_planted | INT | Dynamites planted |
| 19 | topshots[9] | dynamites_defused | INT | Dynamites defused |
| 20 | topshots[10] | times_revived | INT | Times revived |
| 21 | topshots[11] | bullets_fired | INT | Total shots fired |
| 22 | (recalc) | dpm | REAL | DPM (recalculated) |
| 23 | tp/1000/60 | time_minutes | REAL | Time in minutes (deprecated) |
| 24 | topshots[13] | tank_meatshield | REAL | Tank/meatshield score |
| 25 | topshots[14] | time_dead_ratio | REAL | Time dead ratio % |
| 26 | (unused) | - | - | - |
| 27 | kd | kd_ratio | REAL | Kill/death ratio |
| 28 | topshots[15] | most_useful_kills | INT | Most useful kills |
| 29 | topshots[16]/1000 | denied_playtime | INT | Denied playtime (seconds) |
| 30 | multikills[1] | double_kills | INT | 2x multikills |
| 31 | multikills[2] | triple_kills | INT | 3x multikills |
| 32 | multikills[3] | quad_kills | INT | 4x multikills |
| 33 | multikills[4] | multi_kills | INT | 5x multikills |
| 34 | multikills[5] | mega_kills | INT | 6x multikills |
| 35 | topshots[17] | useless_kills | INT | Useless kills |
| 36 | topshots[18] | full_selfkills | INT | Full selfkills |
| 37 | topshots[19] | repairs_constructions | INT | Repairs/constructions |
| 38 | topshots[20] | revives_given | INT | Revives given |

---

## üí° Usage Examples

### Basic Usage

```python
from community_stats_parser import C0RNP0RN3StatsParser

# Create parser instance
parser = C0RNP0RN3StatsParser()

# Parse a stats file
result = parser.parse_stats_file('local_stats/2025-10-02-211808-etl_adlernest-round-1.txt')

if result['success']:
    print(f"Map: {result['map_name']}")
    print(f"Round: {result['round_num']}")
    print(f"Time: {result['actual_time']} ({result['actual_time_seconds']}s)")
    print(f"Players: {len(result['players'])}")
    
    for player in result['players']:
        print(f"  {player['name']}: {player['kills']}K/{player['deaths']}D, {player['dpm']} DPM")
else:
    print(f"Parse failed: {result.get('error')}")
```

### Parse with Round 2 Differential

```python
# Parse Round 2 file (automatically finds and subtracts Round 1)
result = parser.parse_stats_file('local_stats/2025-10-02-212249-etl_adlernest-round-2.txt')

if result['is_round_2_differential']:
    print("‚úÖ Successfully calculated Round 2-only stats")
    print(f"Used Round 1 file: {result['round_1_file']}")
```

### Bulk Import

```python
import glob

parser = C0RNP0RN3StatsParser()

for file_path in glob.glob('local_stats/*.txt'):
    try:
        result = parser.parse_stats_file(file_path)
        if result['success']:
            # Process result (save to database, etc.)
            print(f"‚úÖ Parsed: {file_path}")
        else:
            print(f"‚ùå Failed: {file_path} - {result.get('error')}")
    except Exception as e:
        print(f"‚ùå Exception: {file_path} - {e}")
```

---

## üêõ Error Handling

### Common Errors

**1. File Not Found**
```python
if not os.path.exists(file_path):
    return {
        'success': False,
        'error': f'File not found: {file_path}'
    }
```

**2. Malformed Header**
```python
try:
    parts = header.split('\\')
    if len(parts) < 9:
        raise ValueError(f'Header has {len(parts)} fields, expected 9')
except Exception as e:
    return {
        'success': False,
        'error': f'Failed to parse header: {e}'
    }
```

**3. Invalid Player Line**
```python
try:
    fields = objective_part.split()
    # Parse fields...
except (IndexError, ValueError) as e:
    logger.warning(f'Failed to parse player {guid}: {e}')
    # Use defaults
```

**4. Round 1 Not Found**
```python
if is_round_2 and not round_1_file:
    logger.warning('Round 2 file but no Round 1 found - using cumulative stats')
    # Continue with cumulative data
```

### Validation

```python
def validate_player_data(player: dict) -> bool:
    """Validate parsed player data"""
    # Check required fields
    required = ['guid', 'name', 'team', 'kills', 'deaths', 'damage_given']
    if not all(key in player for key in required):
        return False
    
    # Check data ranges
    if player['kills'] < 0 or player['deaths'] < 0:
        return False
    
    if player['team'] not in [1, 2]:
        return False
    
    # Check GUID format (8 hex characters)
    if len(player['guid']) != 8:
        return False
    
    return True
```

---

**Parser Version:** 3.0  
**Last Updated:** October 3, 2025  
**Status:** Production Ready ‚úÖ
